[{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\dev-dist\\sw.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'importScripts' is not defined.","line":34,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'define' is not defined.","line":70,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":70,"endColumn":7}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// If the loader is already loaded, just stop.\nif (!self.define) {\n  let registry = {};\n\n  // Used for `eval` and `importScripts` where we can't get script URL by other means.\n  // In both cases, it's safe to use a global var because those functions are synchronous.\n  let nextDefineUri;\n\n  const singleRequire = (uri, parentUri) => {\n    uri = new URL(uri + \".js\", parentUri).href;\n    return registry[uri] || (\n      \n        new Promise(resolve => {\n          if (\"document\" in self) {\n            const script = document.createElement(\"script\");\n            script.src = uri;\n            script.onload = resolve;\n            document.head.appendChild(script);\n          } else {\n            nextDefineUri = uri;\n            importScripts(uri);\n            resolve();\n          }\n        })\n      \n      .then(() => {\n        let promise = registry[uri];\n        if (!promise) {\n          throw new Error(`Module ${uri} didnÔÇÖt register its module`);\n        }\n        return promise;\n      })\n    );\n  };\n\n  self.define = (depsNames, factory) => {\n    const uri = nextDefineUri || (\"document\" in self ? document.currentScript.src : \"\") || location.href;\n    if (registry[uri]) {\n      // Module is already loading or loaded.\n      return;\n    }\n    let exports = {};\n    const require = depUri => singleRequire(depUri, uri);\n    const specialDeps = {\n      module: { uri },\n      exports,\n      require\n    };\n    registry[uri] = Promise.all(depsNames.map(\n      depName => specialDeps[depName] || require(depName)\n    )).then(deps => {\n      factory(...deps);\n      return exports;\n    });\n  };\n}\ndefine(['./workbox-2ae722a1'], (function (workbox) { 'use strict';\n\n  self.skipWaiting();\n  workbox.clientsClaim();\n\n  /**\n   * The precacheAndRoute() method efficiently caches and responds to\n   * requests for URLs in the manifest.\n   * See https://goo.gl/S9QRab\n   */\n  workbox.precacheAndRoute([{\n    \"url\": \"index.html\",\n    \"revision\": \"0.70sob4nknu4\"\n  }], {});\n  workbox.cleanupOutdatedCaches();\n  workbox.registerRoute(new workbox.NavigationRoute(workbox.createHandlerBoundToURL(\"index.html\"), {\n    allowlist: [/^\\/$/]\n  }));\n  workbox.registerRoute(/^https:\\/\\/fonts\\.googleapis\\.com\\/.*/i, new workbox.CacheFirst({\n    \"cacheName\": \"google-fonts-stylesheets\",\n    plugins: [new workbox.ExpirationPlugin({\n      maxEntries: 10,\n      maxAgeSeconds: 31536000\n    })]\n  }), 'GET');\n\n}));\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\dev-dist\\workbox-2ae722a1.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'define' is not defined.","line":1,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'_' is not defined.","line":5,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":6,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":15},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":6,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":6,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[143,143],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/ban-types","message":"Definition for rule '@typescript-eslint/ban-types' was not found.","line":52,"column":7,"endLine":52,"endColumn":63,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/ban-types","message":"Definition for rule '@typescript-eslint/ban-types' was not found.","line":419,"column":5,"endLine":419,"endColumn":61,"severity":2,"nodeType":null},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":435,"column":5,"severity":1,"nodeType":null,"fix":{"range":[16918,16940],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'_' is not defined.","line":458,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":458,"endColumn":41},{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":459,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":459,"endColumn":15},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":459,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":459,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[17452,17452],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-unsafe-member-access","message":"Definition for rule '@typescript-eslint/no-unsafe-member-access' was not found.","line":752,"column":11,"endLine":752,"endColumn":81,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-assignment","message":"Definition for rule '@typescript-eslint/no-unsafe-assignment' was not found.","line":754,"column":13,"endLine":754,"endColumn":80,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-assignment","message":"Definition for rule '@typescript-eslint/no-unsafe-assignment' was not found.","line":948,"column":11,"endLine":948,"endColumn":78,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-assignment","message":"Definition for rule '@typescript-eslint/no-unsafe-assignment' was not found.","line":964,"column":13,"endLine":964,"endColumn":80,"severity":2,"nodeType":null},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":970,"column":13,"severity":1,"nodeType":null,"fix":{"range":[36116,36138],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'registration' is not defined.","line":1197,"column":53,"nodeType":"Identifier","messageId":"undef","endLine":1197,"endColumn":65},{"ruleId":"@typescript-eslint/ban-types","message":"Definition for rule '@typescript-eslint/ban-types' was not found.","line":1257,"column":5,"endLine":1257,"endColumn":61,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/ban-types","message":"Definition for rule '@typescript-eslint/ban-types' was not found.","line":1275,"column":5,"endLine":1275,"endColumn":61,"severity":2,"nodeType":null},{"ruleId":"no-func-assign","severity":2,"message":"'_extends' is a function.","line":1291,"column":14,"nodeType":"Identifier","messageId":"isAFunction","endLine":1291,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'_' is not defined.","line":1545,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":1545,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":1546,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":1546,"endColumn":15},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":1546,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":1546,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[58950,58950],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1967,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":1967,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'_' is not defined.","line":2258,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":2258,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":2259,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":2259,"endColumn":15},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2259,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":2259,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[85819,85819],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-undef","severity":2,"message":"'ExtendableEvent' is not defined.","line":2337,"column":56,"nodeType":"Identifier","messageId":"undef","endLine":2337,"endColumn":71},{"ruleId":"no-undef","severity":2,"message":"'FetchEvent' is not defined.","line":2376,"column":61,"nodeType":"Identifier","messageId":"undef","endLine":2376,"endColumn":71},{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":2411,"column":15,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":2411,"endColumn":45},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":2603,"column":35,"severity":1,"nodeType":null,"fix":{"range":[100096,100118],"text":" "}},{"ruleId":"no-undef","severity":2,"message":"'FetchEvent' is not defined.","line":2877,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":2877,"endColumn":42},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":2945,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":2945,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'_' is not defined.","line":3132,"column":43,"nodeType":"Identifier","messageId":"undef","endLine":3132,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":3133,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":3133,"endColumn":15},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":3133,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":3133,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[119930,119930],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":3266,"column":11,"severity":1,"nodeType":null,"fix":{"range":[123931,123951],"text":" "}},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":3381,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":3381,"endColumn":25},{"ruleId":"@typescript-eslint/no-unsafe-return","message":"Definition for rule '@typescript-eslint/no-unsafe-return' was not found.","line":3786,"column":9,"endLine":3786,"endColumn":72,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-unsafe-return","message":"Definition for rule '@typescript-eslint/no-unsafe-return' was not found.","line":3833,"column":9,"endLine":3833,"endColumn":72,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":35,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"define(['exports'], (function (exports) { 'use strict';\n\n    // @ts-ignore\n    try {\n      self['workbox:core:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const logger = (() => {\n      // Don't overwrite this value if it's already set.\n      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n      if (!('__WB_DISABLE_DEV_LOGS' in globalThis)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n      }\n      let inGroup = false;\n      const methodToColorMap = {\n        debug: `#7f8c8d`,\n        log: `#2ecc71`,\n        warn: `#f39c12`,\n        error: `#c0392b`,\n        groupCollapsed: `#3498db`,\n        groupEnd: null // No colored prefix on groupEnd\n      };\n      const print = function (method, args) {\n        if (self.__WB_DISABLE_DEV_LOGS) {\n          return;\n        }\n        if (method === 'groupCollapsed') {\n          // Safari doesn't print all console.groupCollapsed() arguments:\n          // https://bugs.webkit.org/show_bug.cgi?id=182754\n          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n            console[method](...args);\n            return;\n          }\n        }\n        const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`];\n        // When in a group, the workbox prefix is not displayed.\n        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n        console[method](...logPrefix, ...args);\n        if (method === 'groupCollapsed') {\n          inGroup = true;\n        }\n        if (method === 'groupEnd') {\n          inGroup = false;\n        }\n      };\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      const api = {};\n      const loggerMethods = Object.keys(methodToColorMap);\n      for (const key of loggerMethods) {\n        const method = key;\n        api[method] = (...args) => {\n          print(method, args);\n        };\n      }\n      return api;\n    })();\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const messages$1 = {\n      'invalid-value': ({\n        paramName,\n        validValueDescription,\n        value\n      }) => {\n        if (!paramName || !validValueDescription) {\n          throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n      },\n      'not-an-array': ({\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        if (!moduleName || !className || !funcName || !paramName) {\n          throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n      },\n      'incorrect-type': ({\n        expectedType,\n        paramName,\n        moduleName,\n        className,\n        funcName\n      }) => {\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n      },\n      'incorrect-class': ({\n        expectedClassName,\n        paramName,\n        moduleName,\n        className,\n        funcName,\n        isReturnValueProblem\n      }) => {\n        if (!expectedClassName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        if (isReturnValueProblem) {\n          return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n      },\n      'missing-a-method': ({\n        expectedMethod,\n        paramName,\n        moduleName,\n        className,\n        funcName\n      }) => {\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n          throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n      },\n      'add-to-cache-list-unexpected-type': ({\n        entry\n      }) => {\n        return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;\n      },\n      'add-to-cache-list-conflicting-entries': ({\n        firstEntry,\n        secondEntry\n      }) => {\n        if (!firstEntry || !secondEntry) {\n          throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;\n      },\n      'plugin-error-request-will-fetch': ({\n        thrownErrorMessage\n      }) => {\n        if (!thrownErrorMessage) {\n          throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n        }\n        return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;\n      },\n      'invalid-cache-name': ({\n        cacheNameId,\n        value\n      }) => {\n        if (!cacheNameId) {\n          throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;\n      },\n      'unregister-route-but-not-found-with-method': ({\n        method\n      }) => {\n        if (!method) {\n          throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;\n      },\n      'unregister-route-route-not-registered': () => {\n        return `The route you're trying to unregister was not previously ` + `registered.`;\n      },\n      'queue-replay-failed': ({\n        name\n      }) => {\n        return `Replaying the background sync queue '${name}' failed.`;\n      },\n      'duplicate-queue-name': ({\n        name\n      }) => {\n        return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;\n      },\n      'expired-test-without-max-age': ({\n        methodName,\n        paramName\n      }) => {\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n      },\n      'unsupported-route-type': ({\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;\n      },\n      'not-array-of-class': ({\n        value,\n        expectedClass,\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;\n      },\n      'max-entries-or-age-required': ({\n        moduleName,\n        className,\n        funcName\n      }) => {\n        return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;\n      },\n      'statuses-or-headers-required': ({\n        moduleName,\n        className,\n        funcName\n      }) => {\n        return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;\n      },\n      'invalid-string': ({\n        moduleName,\n        funcName,\n        paramName\n      }) => {\n        if (!paramName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;\n      },\n      'channel-name-required': () => {\n        return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;\n      },\n      'invalid-responses-are-same-args': () => {\n        return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;\n      },\n      'expire-custom-caches-only': () => {\n        return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;\n      },\n      'unit-must-be-bytes': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was \"${normalizedRangeHeader}\"`;\n      },\n      'single-range-only': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n      },\n      'invalid-range-values': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n      },\n      'no-range-header': () => {\n        return `No Range header was found in the Request provided.`;\n      },\n      'range-not-satisfiable': ({\n        size,\n        start,\n        end\n      }) => {\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n      },\n      'attempt-to-cache-non-get-request': ({\n        url,\n        method\n      }) => {\n        return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;\n      },\n      'cache-put-with-no-response': ({\n        url\n      }) => {\n        return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;\n      },\n      'no-response': ({\n        url,\n        error\n      }) => {\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n          message += ` The underlying error is ${error}.`;\n        }\n        return message;\n      },\n      'bad-precaching-response': ({\n        url,\n        status\n      }) => {\n        return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);\n      },\n      'non-precached-url': ({\n        url\n      }) => {\n        return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;\n      },\n      'add-to-cache-list-conflicting-integrities': ({\n        url\n      }) => {\n        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;\n      },\n      'missing-precache-entry': ({\n        cacheName,\n        url\n      }) => {\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n      },\n      'cross-origin-copy-response': ({\n        origin\n      }) => {\n        return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;\n      },\n      'opaque-streams-source': ({\n        type\n      }) => {\n        const message = `One of the workbox-streams sources resulted in an ` + `'${type}' response.`;\n        if (type === 'opaqueredirect') {\n          return `${message} Please do not use a navigation request that results ` + `in a redirect as a source.`;\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const generatorFunction = (code, details = {}) => {\n      const message = messages$1[code];\n      if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n      }\n      return message(details);\n    };\n    const messageGenerator = generatorFunction;\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Workbox errors should be thrown with this class.\n     * This allows use to ensure the type easily in tests,\n     * helps developers identify errors from workbox\n     * easily and allows use to optimise error\n     * messages correctly.\n     *\n     * @private\n     */\n    class WorkboxError extends Error {\n      /**\n       *\n       * @param {string} errorCode The error code that\n       * identifies this particular error.\n       * @param {Object=} details Any relevant arguments\n       * that will help developers identify issues should\n       * be added as a key on the context object.\n       */\n      constructor(errorCode, details) {\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /*\n     * This method throws if the supplied value is not an array.\n     * The destructed values are required to produce a meaningful error for users.\n     * The destructed and restructured object is so it's clear what is\n     * needed.\n     */\n    const isArray = (value, details) => {\n      if (!Array.isArray(value)) {\n        throw new WorkboxError('not-an-array', details);\n      }\n    };\n    const hasMethod = (object, expectedMethod, details) => {\n      const type = typeof object[expectedMethod];\n      if (type !== 'function') {\n        details['expectedMethod'] = expectedMethod;\n        throw new WorkboxError('missing-a-method', details);\n      }\n    };\n    const isType = (object, expectedType, details) => {\n      if (typeof object !== expectedType) {\n        details['expectedType'] = expectedType;\n        throw new WorkboxError('incorrect-type', details);\n      }\n    };\n    const isInstance = (object,\n    // Need the general type to do the check later.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    expectedClass, details) => {\n      if (!(object instanceof expectedClass)) {\n        details['expectedClassName'] = expectedClass.name;\n        throw new WorkboxError('incorrect-class', details);\n      }\n    };\n    const isOneOf = (value, validValues, details) => {\n      if (!validValues.includes(value)) {\n        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new WorkboxError('invalid-value', details);\n      }\n    };\n    const isArrayOfClass = (value,\n    // Need general type to do check later.\n    expectedClass,\n    // eslint-disable-line\n    details) => {\n      const error = new WorkboxError('not-array-of-class', details);\n      if (!Array.isArray(value)) {\n        throw error;\n      }\n      for (const item of value) {\n        if (!(item instanceof expectedClass)) {\n          throw error;\n        }\n      }\n    };\n    const finalAssertExports = {\n      hasMethod,\n      isArray,\n      isInstance,\n      isOneOf,\n      isType,\n      isArrayOfClass\n    };\n\n    // @ts-ignore\n    try {\n      self['workbox:routing:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The default HTTP method, 'GET', used when there's no specific method\n     * configured for a route.\n     *\n     * @type {string}\n     *\n     * @private\n     */\n    const defaultMethod = 'GET';\n    /**\n     * The list of valid HTTP methods associated with requests that could be routed.\n     *\n     * @type {Array<string>}\n     *\n     * @private\n     */\n    const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {function()|Object} handler Either a function, or an object with a\n     * 'handle' method.\n     * @return {Object} An object with a handle method.\n     *\n     * @private\n     */\n    const normalizeHandler = handler => {\n      if (handler && typeof handler === 'object') {\n        {\n          finalAssertExports.hasMethod(handler, 'handle', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'handler'\n          });\n        }\n        return handler;\n      } else {\n        {\n          finalAssertExports.isType(handler, 'function', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'handler'\n          });\n        }\n        return {\n          handle: handler\n        };\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n     * The \"match\" callback determine if a route should be used to \"handle\" a\n     * request by returning a non-falsy value if it can. The \"handler\" callback\n     * is called when there is a match and should return a Promise that resolves\n     * to a `Response`.\n     *\n     * @memberof workbox-routing\n     */\n    class Route {\n      /**\n       * Constructor for Route class.\n       *\n       * @param {workbox-routing~matchCallback} match\n       * A callback function that determines whether the route matches a given\n       * `fetch` event by returning a non-falsy value.\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resolving to a Response.\n       * @param {string} [method='GET'] The HTTP method to match the Route\n       * against.\n       */\n      constructor(match, handler, method = defaultMethod) {\n        {\n          finalAssertExports.isType(match, 'function', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'match'\n          });\n          if (method) {\n            finalAssertExports.isOneOf(method, validMethods, {\n              paramName: 'method'\n            });\n          }\n        }\n        // These values are referenced directly by Router so cannot be\n        // altered by minificaton.\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n      }\n      /**\n       *\n       * @param {workbox-routing-handlerCallback} handler A callback\n       * function that returns a Promise resolving to a Response\n       */\n      setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * RegExpRoute makes it easy to create a regular expression based\n     * {@link workbox-routing.Route}.\n     *\n     * For same-origin requests the RegExp only needs to match part of the URL. For\n     * requests against third-party servers, you must define a RegExp that matches\n     * the start of the URL.\n     *\n     * @memberof workbox-routing\n     * @extends workbox-routing.Route\n     */\n    class RegExpRoute extends Route {\n      /**\n       * If the regular expression contains\n       * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n       * the captured values will be passed to the\n       * {@link workbox-routing~handlerCallback} `params`\n       * argument.\n       *\n       * @param {RegExp} regExp The regular expression to match against URLs.\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {string} [method='GET'] The HTTP method to match the Route\n       * against.\n       */\n      constructor(regExp, handler, method) {\n        {\n          finalAssertExports.isInstance(regExp, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'RegExpRoute',\n            funcName: 'constructor',\n            paramName: 'pattern'\n          });\n        }\n        const match = ({\n          url\n        }) => {\n          const result = regExp.exec(url.href);\n          // Return immediately if there's no match.\n          if (!result) {\n            return;\n          }\n          // Require that the match start at the first character in the URL string\n          // if it's a cross-origin request.\n          // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n          // behind this behavior.\n          if (url.origin !== location.origin && result.index !== 0) {\n            {\n              logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n            }\n            return;\n          }\n          // If the route matches, but there aren't any capture groups defined, then\n          // this will return [], which is truthy and therefore sufficient to\n          // indicate a match.\n          // If there are capture groups, then it will return their values.\n          return result.slice(1);\n        };\n        super(match, handler, method);\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const getFriendlyURL = url => {\n      const urlObj = new URL(String(url), location.href);\n      // See https://github.com/GoogleChrome/workbox/issues/2323\n      // We want to include everything, except for the origin if it's same-origin.\n      return urlObj.href.replace(new RegExp(`^${location.origin}`), '');\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Router can be used to process a `FetchEvent` using one or more\n     * {@link workbox-routing.Route}, responding with a `Response` if\n     * a matching route exists.\n     *\n     * If no route matches a given a request, the Router will use a \"default\"\n     * handler if one is defined.\n     *\n     * Should the matching Route throw an error, the Router will use a \"catch\"\n     * handler if one is defined to gracefully deal with issues and respond with a\n     * Request.\n     *\n     * If a request matches multiple routes, the **earliest** registered route will\n     * be used to respond to the request.\n     *\n     * @memberof workbox-routing\n     */\n    class Router {\n      /**\n       * Initializes a new Router.\n       */\n      constructor() {\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n      }\n      /**\n       * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n       * method name ('GET', etc.) to an array of all the corresponding `Route`\n       * instances that are registered.\n       */\n      get routes() {\n        return this._routes;\n      }\n      /**\n       * Adds a fetch event listener to respond to events when a route matches\n       * the event's request.\n       */\n      addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', event => {\n          const {\n            request\n          } = event;\n          const responsePromise = this.handleRequest({\n            request,\n            event\n          });\n          if (responsePromise) {\n            event.respondWith(responsePromise);\n          }\n        });\n      }\n      /**\n       * Adds a message event listener for URLs to cache from the window.\n       * This is useful to cache resources loaded on the page prior to when the\n       * service worker started controlling it.\n       *\n       * The format of the message data sent from the window should be as follows.\n       * Where the `urlsToCache` array may consist of URL strings or an array of\n       * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n       *\n       * ```\n       * {\n       *   type: 'CACHE_URLS',\n       *   payload: {\n       *     urlsToCache: [\n       *       './script1.js',\n       *       './script2.js',\n       *       ['./script3.js', {mode: 'no-cors'}],\n       *     ],\n       *   },\n       * }\n       * ```\n       */\n      addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', event => {\n          // event.data is type 'any'\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          if (event.data && event.data.type === 'CACHE_URLS') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const {\n              payload\n            } = event.data;\n            {\n              logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n            }\n            const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n              if (typeof entry === 'string') {\n                entry = [entry];\n              }\n              const request = new Request(...entry);\n              return this.handleRequest({\n                request,\n                event\n              });\n              // TODO(philipwalton): TypeScript errors without this typecast for\n              // some reason (probably a bug). The real type here should work but\n              // doesn't: `Array<Promise<Response> | undefined>`.\n            })); // TypeScript\n            event.waitUntil(requestPromises);\n            // If a MessageChannel was used, reply to the message on success.\n            if (event.ports && event.ports[0]) {\n              void requestPromises.then(() => event.ports[0].postMessage(true));\n            }\n          }\n        });\n      }\n      /**\n       * Apply the routing rules to a FetchEvent object to get a Response from an\n       * appropriate Route's handler.\n       *\n       * @param {Object} options\n       * @param {Request} options.request The request to handle.\n       * @param {ExtendableEvent} options.event The event that triggered the\n       *     request.\n       * @return {Promise<Response>|undefined} A promise is returned if a\n       *     registered route can handle the request. If there is no matching\n       *     route and there's no `defaultHandler`, `undefined` is returned.\n       */\n      handleRequest({\n        request,\n        event\n      }) {\n        {\n          finalAssertExports.isInstance(request, Request, {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'handleRequest',\n            paramName: 'options.request'\n          });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n          {\n            logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n          }\n          return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const {\n          params,\n          route\n        } = this.findMatchingRoute({\n          event,\n          request,\n          sameOrigin,\n          url\n        });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        {\n          if (handler) {\n            debugMessages.push([`Found a route to handle this request:`, route]);\n            if (params) {\n              debugMessages.push([`Passing the following params to the route's handler:`, params]);\n            }\n          }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n          {\n            debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);\n          }\n          handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n          {\n            // No handler so Workbox will do nothing. If logs is set of debug\n            // i.e. verbose, we should print out this information.\n            logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n          }\n          return;\n        }\n        {\n          // We have a handler, meaning Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n          debugMessages.forEach(msg => {\n            if (Array.isArray(msg)) {\n              logger.log(...msg);\n            } else {\n              logger.log(msg);\n            }\n          });\n          logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n          responsePromise = handler.handle({\n            url,\n            request,\n            event,\n            params\n          });\n        } catch (err) {\n          responsePromise = Promise.reject(err);\n        }\n        // Get route's catch handler, if it exists\n        const catchHandler = route && route.catchHandler;\n        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n          responsePromise = responsePromise.catch(async err => {\n            // If there's a route catch handler, process that first\n            if (catchHandler) {\n              {\n                // Still include URL here as it will be async from the console group\n                // and may not make sense without the URL\n                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n                logger.error(`Error thrown by:`, route);\n                logger.error(err);\n                logger.groupEnd();\n              }\n              try {\n                return await catchHandler.handle({\n                  url,\n                  request,\n                  event,\n                  params\n                });\n              } catch (catchErr) {\n                if (catchErr instanceof Error) {\n                  err = catchErr;\n                }\n              }\n            }\n            if (this._catchHandler) {\n              {\n                // Still include URL here as it will be async from the console group\n                // and may not make sense without the URL\n                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n                logger.error(`Error thrown by:`, route);\n                logger.error(err);\n                logger.groupEnd();\n              }\n              return this._catchHandler.handle({\n                url,\n                request,\n                event\n              });\n            }\n            throw err;\n          });\n        }\n        return responsePromise;\n      }\n      /**\n       * Checks a request and URL (and optionally an event) against the list of\n       * registered routes, and if there's a match, returns the corresponding\n       * route along with any params generated by the match.\n       *\n       * @param {Object} options\n       * @param {URL} options.url\n       * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n       *     against the current origin.\n       * @param {Request} options.request The request to match.\n       * @param {Event} options.event The corresponding event.\n       * @return {Object} An object with `route` and `params` properties.\n       *     They are populated if a matching route was found or `undefined`\n       *     otherwise.\n       */\n      findMatchingRoute({\n        url,\n        sameOrigin,\n        request,\n        event\n      }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n          let params;\n          // route.match returns type any, not possible to change right now.\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          const matchResult = route.match({\n            url,\n            sameOrigin,\n            request,\n            event\n          });\n          if (matchResult) {\n            {\n              // Warn developers that using an async matchCallback is almost always\n              // not the right thing to do.\n              if (matchResult instanceof Promise) {\n                logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);\n              }\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2079\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            params = matchResult;\n            if (Array.isArray(params) && params.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              params = undefined;\n            } else if (matchResult.constructor === Object &&\n            // eslint-disable-line\n            Object.keys(matchResult).length === 0) {\n              // Instead of passing an empty object in as params, use undefined.\n              params = undefined;\n            } else if (typeof matchResult === 'boolean') {\n              // For the boolean value true (rather than just something truth-y),\n              // don't set params.\n              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n              params = undefined;\n            }\n            // Return early if have a match.\n            return {\n              route,\n              params\n            };\n          }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n      }\n      /**\n       * Define a default `handler` that's called when no routes explicitly\n       * match the incoming request.\n       *\n       * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n       *\n       * Without a default handler, unmatched requests will go against the\n       * network as if there were no service worker present.\n       *\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {string} [method='GET'] The HTTP method to associate with this\n       * default handler. Each method has its own default.\n       */\n      setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n      }\n      /**\n       * If a Route throws an error while handling a request, this `handler`\n       * will be called and given a chance to provide a response.\n       *\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       */\n      setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n      }\n      /**\n       * Registers a route with the router.\n       *\n       * @param {workbox-routing.Route} route The route to register.\n       */\n      registerRoute(route) {\n        {\n          finalAssertExports.isType(route, 'object', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.hasMethod(route, 'match', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.isType(route.handler, 'object', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.hasMethod(route.handler, 'handle', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route.handler'\n          });\n          finalAssertExports.isType(route.method, 'string', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route.method'\n          });\n        }\n        if (!this._routes.has(route.method)) {\n          this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n      }\n      /**\n       * Unregisters a route with the router.\n       *\n       * @param {workbox-routing.Route} route The route to unregister.\n       */\n      unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n          throw new WorkboxError('unregister-route-but-not-found-with-method', {\n            method: route.method\n          });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n          this._routes.get(route.method).splice(routeIndex, 1);\n        } else {\n          throw new WorkboxError('unregister-route-route-not-registered');\n        }\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let defaultRouter;\n    /**\n     * Creates a new, singleton Router instance if one does not exist. If one\n     * does already exist, that instance is returned.\n     *\n     * @private\n     * @return {Router}\n     */\n    const getOrCreateDefaultRouter = () => {\n      if (!defaultRouter) {\n        defaultRouter = new Router();\n        // The helpers that use the default Router assume these listeners exist.\n        defaultRouter.addFetchListener();\n        defaultRouter.addCacheListener();\n      }\n      return defaultRouter;\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Easily register a RegExp, string, or function with a caching\n     * strategy to a singleton Router instance.\n     *\n     * This method will generate a Route for you if needed and\n     * call {@link workbox-routing.Router#registerRoute}.\n     *\n     * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture\n     * If the capture param is a `Route`, all other arguments will be ignored.\n     * @param {workbox-routing~handlerCallback} [handler] A callback\n     * function that returns a Promise resulting in a Response. This parameter\n     * is required if `capture` is not a `Route` object.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     * @return {workbox-routing.Route} The generated `Route`.\n     *\n     * @memberof workbox-routing\n     */\n    function registerRoute(capture, handler, method) {\n      let route;\n      if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location.href);\n        {\n          if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n            throw new WorkboxError('invalid-string', {\n              moduleName: 'workbox-routing',\n              funcName: 'registerRoute',\n              paramName: 'capture'\n            });\n          }\n          // We want to check if Express-style wildcards are in the pathname only.\n          // TODO: Remove this log message in v4.\n          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture;\n          // See https://github.com/pillarjs/path-to-regexp#parameters\n          const wildcards = '[*:?+]';\n          if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n            logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n          }\n        }\n        const matchCallback = ({\n          url\n        }) => {\n          {\n            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n              logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n            }\n          }\n          return url.href === captureUrl.href;\n        };\n        // If `capture` is a string then `handler` and `method` must be present.\n        route = new Route(matchCallback, handler, method);\n      } else if (capture instanceof RegExp) {\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\n        route = new RegExpRoute(capture, handler, method);\n      } else if (typeof capture === 'function') {\n        // If `capture` is a function then `handler` and `method` must be present.\n        route = new Route(capture, handler, method);\n      } else if (capture instanceof Route) {\n        route = capture;\n      } else {\n        throw new WorkboxError('unsupported-route-type', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      }\n      const defaultRouter = getOrCreateDefaultRouter();\n      defaultRouter.registerRoute(route);\n      return route;\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const _cacheNameDetails = {\n      googleAnalytics: 'googleAnalytics',\n      precache: 'precache-v2',\n      prefix: 'workbox',\n      runtime: 'runtime',\n      suffix: typeof registration !== 'undefined' ? registration.scope : ''\n    };\n    const _createCacheName = cacheName => {\n      return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');\n    };\n    const eachCacheNameDetail = fn => {\n      for (const key of Object.keys(_cacheNameDetails)) {\n        fn(key);\n      }\n    };\n    const cacheNames = {\n      updateDetails: details => {\n        eachCacheNameDetail(key => {\n          if (typeof details[key] === 'string') {\n            _cacheNameDetails[key] = details[key];\n          }\n        });\n      },\n      getGoogleAnalyticsName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n      },\n      getPrecacheName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n      },\n      getPrefix: () => {\n        return _cacheNameDetails.prefix;\n      },\n      getRuntimeName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n      },\n      getSuffix: () => {\n        return _cacheNameDetails.suffix;\n      }\n    };\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A helper function that prevents a promise from being flagged as unused.\n     *\n     * @private\n     **/\n    function dontWaitFor(promise) {\n      // Effective no-op.\n      void promise.then(() => {});\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    // Callbacks to be executed whenever there's a quota error.\n    // Can't change Function type right now.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const quotaErrorCallbacks = new Set();\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds a function to the set of quotaErrorCallbacks that will be executed if\n     * there's a quota error.\n     *\n     * @param {Function} callback\n     * @memberof workbox-core\n     */\n    // Can't change Function type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    function registerQuotaErrorCallback(callback) {\n      {\n        finalAssertExports.isType(callback, 'function', {\n          moduleName: 'workbox-core',\n          funcName: 'register',\n          paramName: 'callback'\n        });\n      }\n      quotaErrorCallbacks.add(callback);\n      {\n        logger.log('Registered a callback to respond to quota errors.', callback);\n      }\n    }\n\n    function _extends() {\n      return _extends = Object.assign ? Object.assign.bind() : function (n) {\n        for (var e = 1; e < arguments.length; e++) {\n          var t = arguments[e];\n          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n      }, _extends.apply(null, arguments);\n    }\n\n    const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n    let idbProxyableTypes;\n    let cursorAdvanceMethods;\n    // This is a function to prevent it throwing up in node environments.\n    function getIdbProxyableTypes() {\n      return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n    }\n    // This is a function to prevent it throwing up in node environments.\n    function getCursorAdvanceMethods() {\n      return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n    }\n    const cursorRequestMap = new WeakMap();\n    const transactionDoneMap = new WeakMap();\n    const transactionStoreNamesMap = new WeakMap();\n    const transformCache = new WeakMap();\n    const reverseTransformCache = new WeakMap();\n    function promisifyRequest(request) {\n      const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n          request.removeEventListener('success', success);\n          request.removeEventListener('error', error);\n        };\n        const success = () => {\n          resolve(wrap(request.result));\n          unlisten();\n        };\n        const error = () => {\n          reject(request.error);\n          unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n      });\n      promise.then(value => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n          cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n      }).catch(() => {});\n      // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n      // is because we create many promises from a single IDBRequest.\n      reverseTransformCache.set(promise, request);\n      return promise;\n    }\n    function cacheDonePromiseForTransaction(tx) {\n      // Early bail if we've already created a done promise for this transaction.\n      if (transactionDoneMap.has(tx)) return;\n      const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n          tx.removeEventListener('complete', complete);\n          tx.removeEventListener('error', error);\n          tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n          resolve();\n          unlisten();\n        };\n        const error = () => {\n          reject(tx.error || new DOMException('AbortError', 'AbortError'));\n          unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n      });\n      // Cache it for later retrieval.\n      transactionDoneMap.set(tx, done);\n    }\n    let idbProxyTraps = {\n      get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n          // Special handling for transaction.done.\n          if (prop === 'done') return transactionDoneMap.get(target);\n          // Polyfill for objectStoreNames because of Edge.\n          if (prop === 'objectStoreNames') {\n            return target.objectStoreNames || transactionStoreNamesMap.get(target);\n          }\n          // Make tx.store return the only store in the transaction, or undefined if there are many.\n          if (prop === 'store') {\n            return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n          }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n      },\n      set(target, prop, value) {\n        target[prop] = value;\n        return true;\n      },\n      has(target, prop) {\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n          return true;\n        }\n        return prop in target;\n      }\n    };\n    function replaceTraps(callback) {\n      idbProxyTraps = callback(idbProxyTraps);\n    }\n    function wrapFunction(func) {\n      // Due to expected object equality (which is enforced by the caching in `wrap`), we\n      // only create one new func per func.\n      // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n      if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n          const tx = func.call(unwrap(this), storeNames, ...args);\n          transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n          return wrap(tx);\n        };\n      }\n      // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n      // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n      // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n      // with real promises, so each advance methods returns a new promise for the cursor object, or\n      // undefined if the end of the cursor has been reached.\n      if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n          // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n          // the original object.\n          func.apply(unwrap(this), args);\n          return wrap(cursorRequestMap.get(this));\n        };\n      }\n      return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n      };\n    }\n    function transformCachableValue(value) {\n      if (typeof value === 'function') return wrapFunction(value);\n      // This doesn't return, it just creates a 'done' promise for the transaction,\n      // which is later returned for transaction.done (see idbObjectHandler).\n      if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n      if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n      // Return the same value back if we're not going to transform it.\n      return value;\n    }\n    function wrap(value) {\n      // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n      // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n      if (value instanceof IDBRequest) return promisifyRequest(value);\n      // If we've already transformed this value before, reuse the transformed value.\n      // This is faster, but it also provides object equality.\n      if (transformCache.has(value)) return transformCache.get(value);\n      const newValue = transformCachableValue(value);\n      // Not all types are transformed.\n      // These may be primitive types, so they can't be WeakMap keys.\n      if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n      }\n      return newValue;\n    }\n    const unwrap = value => reverseTransformCache.get(value);\n\n    /**\n     * Open a database.\n     *\n     * @param name Name of the database.\n     * @param version Schema version.\n     * @param callbacks Additional callbacks.\n     */\n    function openDB(name, version, {\n      blocked,\n      upgrade,\n      blocking,\n      terminated\n    } = {}) {\n      const request = indexedDB.open(name, version);\n      const openPromise = wrap(request);\n      if (upgrade) {\n        request.addEventListener('upgradeneeded', event => {\n          upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n      }\n      if (blocked) {\n        request.addEventListener('blocked', event => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n      }\n      openPromise.then(db => {\n        if (terminated) db.addEventListener('close', () => terminated());\n        if (blocking) {\n          db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));\n        }\n      }).catch(() => {});\n      return openPromise;\n    }\n    /**\n     * Delete a database.\n     *\n     * @param name Name of the database.\n     */\n    function deleteDB(name, {\n      blocked\n    } = {}) {\n      const request = indexedDB.deleteDatabase(name);\n      if (blocked) {\n        request.addEventListener('blocked', event => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n      }\n      return wrap(request).then(() => undefined);\n    }\n    const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\n    const writeMethods = ['put', 'add', 'delete', 'clear'];\n    const cachedMethods = new Map();\n    function getMethod(target, prop) {\n      if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n        return;\n      }\n      if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n      const targetFuncName = prop.replace(/FromIndex$/, '');\n      const useIndex = prop !== targetFuncName;\n      const isWrite = writeMethods.includes(targetFuncName);\n      if (\n      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n      }\n      const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex) target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n      };\n      cachedMethods.set(prop, method);\n      return method;\n    }\n    replaceTraps(oldTraps => _extends({}, oldTraps, {\n      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n    }));\n\n    // @ts-ignore\n    try {\n      self['workbox:expiration:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const DB_NAME = 'workbox-expiration';\n    const CACHE_OBJECT_STORE = 'cache-entries';\n    const normalizeURL = unNormalizedUrl => {\n      const url = new URL(unNormalizedUrl, location.href);\n      url.hash = '';\n      return url.href;\n    };\n    /**\n     * Returns the timestamp model.\n     *\n     * @private\n     */\n    class CacheTimestampsModel {\n      /**\n       *\n       * @param {string} cacheName\n       *\n       * @private\n       */\n      constructor(cacheName) {\n        this._db = null;\n        this._cacheName = cacheName;\n      }\n      /**\n       * Performs an upgrade of indexedDB.\n       *\n       * @param {IDBPDatabase<CacheDbSchema>} db\n       *\n       * @private\n       */\n      _upgradeDb(db) {\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n          keyPath: 'id'\n        });\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n        objStore.createIndex('cacheName', 'cacheName', {\n          unique: false\n        });\n        objStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n      }\n      /**\n       * Performs an upgrade of indexedDB and deletes deprecated DBs.\n       *\n       * @param {IDBPDatabase<CacheDbSchema>} db\n       *\n       * @private\n       */\n      _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n          void deleteDB(this._cacheName);\n        }\n      }\n      /**\n       * @param {string} url\n       * @param {number} timestamp\n       *\n       * @private\n       */\n      async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n          url,\n          timestamp,\n          cacheName: this._cacheName,\n          // Creating an ID from the URL and cache name won't be necessary once\n          // Edge switches to Chromium and all browsers we support work with\n          // array keyPaths.\n          id: this._getId(url)\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n          durability: 'relaxed'\n        });\n        await tx.store.put(entry);\n        await tx.done;\n      }\n      /**\n       * Returns the timestamp stored for a given URL.\n       *\n       * @param {string} url\n       * @return {number | undefined}\n       *\n       * @private\n       */\n      async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n      }\n      /**\n       * Iterates through all the entries in the object store (from newest to\n       * oldest) and removes entries once either `maxCount` is reached or the\n       * entry's timestamp is less than `minTimestamp`.\n       *\n       * @param {number} minTimestamp\n       * @param {number} maxCount\n       * @return {Array<string>}\n       *\n       * @private\n       */\n      async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db.transaction(CACHE_OBJECT_STORE).store.index('timestamp').openCursor(null, 'prev');\n        const entriesToDelete = [];\n        let entriesNotDeletedCount = 0;\n        while (cursor) {\n          const result = cursor.value;\n          // TODO(philipwalton): once we can use a multi-key index, we\n          // won't have to check `cacheName` here.\n          if (result.cacheName === this._cacheName) {\n            // Delete an entry if it's older than the max age or\n            // if we already have the max number allowed.\n            if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n              // TODO(philipwalton): we should be able to delete the\n              // entry right here, but doing so causes an iteration\n              // bug in Safari stable (fixed in TP). Instead we can\n              // store the keys of the entries to delete, and then\n              // delete the separate transactions.\n              // https://github.com/GoogleChrome/workbox/issues/1978\n              // cursor.delete();\n              // We only need to return the URL, not the whole entry.\n              entriesToDelete.push(cursor.value);\n            } else {\n              entriesNotDeletedCount++;\n            }\n          }\n          cursor = await cursor.continue();\n        }\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n        const urlsDeleted = [];\n        for (const entry of entriesToDelete) {\n          await db.delete(CACHE_OBJECT_STORE, entry.id);\n          urlsDeleted.push(entry.url);\n        }\n        return urlsDeleted;\n      }\n      /**\n       * Takes a URL and returns an ID that will be unique in the object store.\n       *\n       * @param {string} url\n       * @return {string}\n       *\n       * @private\n       */\n      _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n      }\n      /**\n       * Returns an open connection to the database.\n       *\n       * @private\n       */\n      async getDb() {\n        if (!this._db) {\n          this._db = await openDB(DB_NAME, 1, {\n            upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n          });\n        }\n        return this._db;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The `CacheExpiration` class allows you define an expiration and / or\n     * limit on the number of responses stored in a\n     * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n     *\n     * @memberof workbox-expiration\n     */\n    class CacheExpiration {\n      /**\n       * To construct a new CacheExpiration instance you must provide at least\n       * one of the `config` properties.\n       *\n       * @param {string} cacheName Name of the cache to apply restrictions to.\n       * @param {Object} config\n       * @param {number} [config.maxEntries] The maximum number of entries to cache.\n       * Entries used the least will be removed as the maximum is reached.\n       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n       * it's treated as stale and removed.\n       * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n       * that will be used when calling `delete()` on the cache.\n       */\n      constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        {\n          finalAssertExports.isType(cacheName, 'string', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor',\n            paramName: 'cacheName'\n          });\n          if (!(config.maxEntries || config.maxAgeSeconds)) {\n            throw new WorkboxError('max-entries-or-age-required', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor'\n            });\n          }\n          if (config.maxEntries) {\n            finalAssertExports.isType(config.maxEntries, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor',\n              paramName: 'config.maxEntries'\n            });\n          }\n          if (config.maxAgeSeconds) {\n            finalAssertExports.isType(config.maxAgeSeconds, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor',\n              paramName: 'config.maxAgeSeconds'\n            });\n          }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n      }\n      /**\n       * Expires entries for the given cache and given criteria.\n       */\n      async expireEntries() {\n        if (this._isRunning) {\n          this._rerunRequested = true;\n          return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n          await cache.delete(url, this._matchOptions);\n        }\n        {\n          if (urlsExpired.length > 0) {\n            logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n            logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n            urlsExpired.forEach(url => logger.log(`    ${url}`));\n            logger.groupEnd();\n          } else {\n            logger.debug(`Cache expiration ran and found no entries to remove.`);\n          }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n          this._rerunRequested = false;\n          dontWaitFor(this.expireEntries());\n        }\n      }\n      /**\n       * Update the timestamp for the given URL. This ensures the when\n       * removing entries based on maximum entries, most recently used\n       * is accurate or when expiring, the timestamp is up-to-date.\n       *\n       * @param {string} url\n       */\n      async updateTimestamp(url) {\n        {\n          finalAssertExports.isType(url, 'string', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'updateTimestamp',\n            paramName: 'url'\n          });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n      }\n      /**\n       * Can be used to check if a URL has expired or not before it's used.\n       *\n       * This requires a look up from IndexedDB, so can be slow.\n       *\n       * Note: This method will not remove the cached entry, call\n       * `expireEntries()` to remove indexedDB and Cache entries.\n       *\n       * @param {string} url\n       * @return {boolean}\n       */\n      async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n          {\n            throw new WorkboxError(`expired-test-without-max-age`, {\n              methodName: 'isURLExpired',\n              paramName: 'maxAgeSeconds'\n            });\n          }\n        } else {\n          const timestamp = await this._timestampModel.getTimestamp(url);\n          const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n          return timestamp !== undefined ? timestamp < expireOlderThan : true;\n        }\n      }\n      /**\n       * Removes the IndexedDB object store used to keep track of cache expiration\n       * metadata.\n       */\n      async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This plugin can be used in a `workbox-strategy` to regularly enforce a\n     * limit on the age and / or the number of cached requests.\n     *\n     * It can only be used with `workbox-strategy` instances that have a\n     * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n     * In other words, it can't be used to expire entries in strategy that uses the\n     * default runtime cache name.\n     *\n     * Whenever a cached response is used or updated, this plugin will look\n     * at the associated cache and remove any old or extra responses.\n     *\n     * When using `maxAgeSeconds`, responses may be used *once* after expiring\n     * because the expiration clean up will not have occurred until *after* the\n     * cached response has been used. If the response has a \"Date\" header, then\n     * a light weight expiration check is performed and the response will not be\n     * used immediately.\n     *\n     * When using `maxEntries`, the entry least-recently requested will be removed\n     * from the cache first.\n     *\n     * @memberof workbox-expiration\n     */\n    class ExpirationPlugin {\n      /**\n       * @param {ExpirationPluginOptions} config\n       * @param {number} [config.maxEntries] The maximum number of entries to cache.\n       * Entries used the least will be removed as the maximum is reached.\n       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n       * it's treated as stale and removed.\n       * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n       * that will be used when calling `delete()` on the cache.\n       * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n       * automatic deletion if the available storage quota has been exceeded.\n       */\n      constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({\n          event,\n          request,\n          cacheName,\n          cachedResponse\n        }) => {\n          if (!cachedResponse) {\n            return null;\n          }\n          const isFresh = this._isResponseDateFresh(cachedResponse);\n          // Expire entries to ensure that even if the expiration date has\n          // expired, it'll only be used once.\n          const cacheExpiration = this._getCacheExpiration(cacheName);\n          dontWaitFor(cacheExpiration.expireEntries());\n          // Update the metadata for the request URL to the current timestamp,\n          // but don't `await` it as we don't want to block the response.\n          const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n          if (event) {\n            try {\n              event.waitUntil(updateTimestampDone);\n            } catch (error) {\n              {\n                // The event may not be a fetch event; only log the URL if it is.\n                if ('request' in event) {\n                  logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for ` + `'${getFriendlyURL(event.request.url)}'.`);\n                }\n              }\n            }\n          }\n          return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({\n          cacheName,\n          request\n        }) => {\n          {\n            finalAssertExports.isType(cacheName, 'string', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'cacheDidUpdate',\n              paramName: 'cacheName'\n            });\n            finalAssertExports.isInstance(request, Request, {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'cacheDidUpdate',\n              paramName: 'request'\n            });\n          }\n          const cacheExpiration = this._getCacheExpiration(cacheName);\n          await cacheExpiration.updateTimestamp(request.url);\n          await cacheExpiration.expireEntries();\n        };\n        {\n          if (!(config.maxEntries || config.maxAgeSeconds)) {\n            throw new WorkboxError('max-entries-or-age-required', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor'\n            });\n          }\n          if (config.maxEntries) {\n            finalAssertExports.isType(config.maxEntries, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor',\n              paramName: 'config.maxEntries'\n            });\n          }\n          if (config.maxAgeSeconds) {\n            finalAssertExports.isType(config.maxAgeSeconds, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor',\n              paramName: 'config.maxAgeSeconds'\n            });\n          }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n          registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n      }\n      /**\n       * A simple helper method to return a CacheExpiration instance for a given\n       * cache name.\n       *\n       * @param {string} cacheName\n       * @return {CacheExpiration}\n       *\n       * @private\n       */\n      _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n          throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n          cacheExpiration = new CacheExpiration(cacheName, this._config);\n          this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n      }\n      /**\n       * @param {Response} cachedResponse\n       * @return {boolean}\n       *\n       * @private\n       */\n      _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n          // We aren't expiring by age, so return true, it's fresh\n          return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n          // Unable to parse date, so assume it's fresh.\n          return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n      }\n      /**\n       * This method will extract the data header and parse it into a useful\n       * value.\n       *\n       * @param {Response} cachedResponse\n       * @return {number|null}\n       *\n       * @private\n       */\n      _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n          return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n          return null;\n        }\n        return headerTime;\n      }\n      /**\n       * This is a helper method that performs two operations:\n       *\n       * - Deletes *all* the underlying Cache instances associated with this plugin\n       * instance, by calling caches.delete() on your behalf.\n       * - Deletes the metadata from IndexedDB used to keep track of expiration\n       * details for each Cache instance.\n       *\n       * When using cache expiration, calling this method is preferable to calling\n       * `caches.delete()` directly, since this will ensure that the IndexedDB\n       * metadata is also cleanly removed and open IndexedDB instances are deleted.\n       *\n       * Note that if you're *not* using cache expiration for a given cache, calling\n       * `caches.delete()` and passing in the cache's name should be sufficient.\n       * There is no Workbox-specific method needed for cleanup in that case.\n       */\n      async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n          await self.caches.delete(cacheName);\n          await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    function stripParams(fullURL, ignoreParams) {\n      const strippedURL = new URL(fullURL);\n      for (const param of ignoreParams) {\n        strippedURL.searchParams.delete(param);\n      }\n      return strippedURL.href;\n    }\n    /**\n     * Matches an item in the cache, ignoring specific URL params. This is similar\n     * to the `ignoreSearch` option, but it allows you to ignore just specific\n     * params (while continuing to match on the others).\n     *\n     * @private\n     * @param {Cache} cache\n     * @param {Request} request\n     * @param {Object} matchOptions\n     * @param {Array<string>} ignoreParams\n     * @return {Promise<Response|undefined>}\n     */\n    async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n      const strippedRequestURL = stripParams(request.url, ignoreParams);\n      // If the request doesn't include any ignored params, match as normal.\n      if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n      }\n      // Otherwise, match by comparing keys\n      const keysOptions = Object.assign(Object.assign({}, matchOptions), {\n        ignoreSearch: true\n      });\n      const cacheKeys = await cache.keys(request, keysOptions);\n      for (const cacheKey of cacheKeys) {\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n          return cache.match(cacheKey, matchOptions);\n        }\n      }\n      return;\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Deferred class composes Promises in a way that allows for them to be\n     * resolved or rejected from outside the constructor. In most cases promises\n     * should be used directly, but Deferreds can be necessary when the logic to\n     * resolve a promise must be separate.\n     *\n     * @private\n     */\n    class Deferred {\n      /**\n       * Creates a promise and exposes its resolve and reject functions as methods.\n       */\n      constructor() {\n        this.promise = new Promise((resolve, reject) => {\n          this.resolve = resolve;\n          this.reject = reject;\n        });\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Runs all of the callback functions, one at a time sequentially, in the order\n     * in which they were registered.\n     *\n     * @memberof workbox-core\n     * @private\n     */\n    async function executeQuotaErrorCallbacks() {\n      {\n        logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);\n      }\n      for (const callback of quotaErrorCallbacks) {\n        await callback();\n        {\n          logger.log(callback, 'is complete.');\n        }\n      }\n      {\n        logger.log('Finished running callbacks.');\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Returns a promise that resolves and the passed number of milliseconds.\n     * This utility is an async/await-friendly version of `setTimeout`.\n     *\n     * @param {number} ms\n     * @return {Promise}\n     * @private\n     */\n    function timeout(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    // @ts-ignore\n    try {\n      self['workbox:strategies:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    function toRequest(input) {\n      return typeof input === 'string' ? new Request(input) : input;\n    }\n    /**\n     * A class created every time a Strategy instance calls\n     * {@link workbox-strategies.Strategy~handle} or\n     * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n     * cache actions around plugin callbacks and keeps track of when the strategy\n     * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n     *\n     * @memberof workbox-strategies\n     */\n    class StrategyHandler {\n      /**\n       * Creates a new instance associated with the passed strategy and event\n       * that's handling the request.\n       *\n       * The constructor also initializes the state that will be passed to each of\n       * the plugins handling this request.\n       *\n       * @param {workbox-strategies.Strategy} strategy\n       * @param {Object} options\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params] The return value from the\n       *     {@link workbox-routing~matchCallback} (if applicable).\n       */\n      constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        {\n          finalAssertExports.isInstance(options.event, ExtendableEvent, {\n            moduleName: 'workbox-strategies',\n            className: 'StrategyHandler',\n            funcName: 'constructor',\n            paramName: 'options.event'\n          });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n          this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n      }\n      /**\n       * Fetches a given request (and invokes any applicable plugin callback\n       * methods) using the `fetchOptions` (for non-navigation requests) and\n       * `plugins` defined on the `Strategy` object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - `requestWillFetch()`\n       * - `fetchDidSucceed()`\n       * - `fetchDidFail()`\n       *\n       * @param {Request|string} input The URL or request to fetch.\n       * @return {Promise<Response>}\n       */\n      async fetch(input) {\n        const {\n          event\n        } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {\n          const possiblePreloadResponse = await event.preloadResponse;\n          if (possiblePreloadResponse) {\n            {\n              logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n            }\n            return possiblePreloadResponse;\n          }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;\n        try {\n          for (const cb of this.iterateCallbacks('requestWillFetch')) {\n            request = await cb({\n              request: request.clone(),\n              event\n            });\n          }\n        } catch (err) {\n          if (err instanceof Error) {\n            throw new WorkboxError('plugin-error-request-will-fetch', {\n              thrownErrorMessage: err.message\n            });\n          }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n          let fetchResponse;\n          // See https://github.com/GoogleChrome/workbox/issues/1796\n          fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n          if (\"development\" !== 'production') {\n            logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n          }\n          for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n            fetchResponse = await callback({\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse\n            });\n          }\n          return fetchResponse;\n        } catch (error) {\n          {\n            logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n          }\n          // `originalRequest` will only exist if a `fetchDidFail` callback\n          // is being used (see above).\n          if (originalRequest) {\n            await this.runCallbacks('fetchDidFail', {\n              error: error,\n              event,\n              originalRequest: originalRequest.clone(),\n              request: pluginFilteredRequest.clone()\n            });\n          }\n          throw error;\n        }\n      }\n      /**\n       * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n       * the response generated by `this.fetch()`.\n       *\n       * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n       * so you do not have to manually call `waitUntil()` on the event.\n       *\n       * @param {Request|string} input The request or URL to fetch and cache.\n       * @return {Promise<Response>}\n       */\n      async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n      }\n      /**\n       * Matches a request from the cache (and invokes any applicable plugin\n       * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n       * defined on the strategy object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - cacheKeyWillBeUsed()\n       * - cachedResponseWillBeUsed()\n       *\n       * @param {Request|string} key The Request or URL to use as the cache key.\n       * @return {Promise<Response|undefined>} A matching response, if found.\n       */\n      async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const {\n          cacheName,\n          matchOptions\n        } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {\n          cacheName\n        });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        {\n          if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n          } else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n          }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n          cachedResponse = (await callback({\n            cacheName,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n            event: this.event\n          })) || undefined;\n        }\n        return cachedResponse;\n      }\n      /**\n       * Puts a request/response pair in the cache (and invokes any applicable\n       * plugin callback methods) using the `cacheName` and `plugins` defined on\n       * the strategy object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - cacheKeyWillBeUsed()\n       * - cacheWillUpdate()\n       * - cacheDidUpdate()\n       *\n       * @param {Request|string} key The request or URL to use as the cache key.\n       * @param {Response} response The response to cache.\n       * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n       * not be cached, and `true` otherwise.\n       */\n      async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        {\n          if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n              url: getFriendlyURL(effectiveRequest.url),\n              method: effectiveRequest.method\n            });\n          }\n          // See https://github.com/GoogleChrome/workbox/issues/2818\n          const vary = response.headers.get('Vary');\n          if (vary) {\n            logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);\n          }\n        }\n        if (!response) {\n          {\n            logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n          }\n          throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url)\n          });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n          {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);\n          }\n          return false;\n        }\n        const {\n          cacheName,\n          matchOptions\n        } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\n        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n        // feature. Consider into ways to only add this behavior if using\n        // precaching.\n        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;\n        {\n          logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n          await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        } catch (error) {\n          if (error instanceof Error) {\n            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n            if (error.name === 'QuotaExceededError') {\n              await executeQuotaErrorCallbacks();\n            }\n            throw error;\n          }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n          await callback({\n            cacheName,\n            oldResponse,\n            newResponse: responseToCache.clone(),\n            request: effectiveRequest,\n            event: this.event\n          });\n        }\n        return true;\n      }\n      /**\n       * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n       * executes any of those callbacks found in sequence. The final `Request`\n       * object returned by the last plugin is treated as the cache key for cache\n       * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n       * been registered, the passed request is returned unmodified\n       *\n       * @param {Request} request\n       * @param {string} mode\n       * @return {Promise<Request>}\n       */\n      async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n          let effectiveRequest = request;\n          for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n            effectiveRequest = toRequest(await callback({\n              mode,\n              request: effectiveRequest,\n              event: this.event,\n              // params has a type any can't change right now.\n              params: this.params // eslint-disable-line\n            }));\n          }\n          this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n      }\n      /**\n       * Returns true if the strategy has at least one plugin with the given\n       * callback.\n       *\n       * @param {string} name The name of the callback to check for.\n       * @return {boolean}\n       */\n      hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n          if (name in plugin) {\n            return true;\n          }\n        }\n        return false;\n      }\n      /**\n       * Runs all plugin callbacks matching the given name, in order, passing the\n       * given param object (merged ith the current plugin state) as the only\n       * argument.\n       *\n       * Note: since this method runs all plugins, it's not suitable for cases\n       * where the return value of a callback needs to be applied prior to calling\n       * the next callback. See\n       * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n       * below for how to handle that case.\n       *\n       * @param {string} name The name of the callback to run within each plugin.\n       * @param {Object} param The object to pass as the first (and only) param\n       *     when executing each callback. This object will be merged with the\n       *     current plugin state prior to callback execution.\n       */\n      async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n          // TODO(philipwalton): not sure why `any` is needed. It seems like\n          // this should work with `as WorkboxPluginCallbackParam[C]`.\n          await callback(param);\n        }\n      }\n      /**\n       * Accepts a callback and returns an iterable of matching plugin callbacks,\n       * where each callback is wrapped with the current handler state (i.e. when\n       * you call each callback, whatever object parameter you pass it will\n       * be merged with the plugin's current state).\n       *\n       * @param {string} name The name fo the callback to run\n       * @return {Array<Function>}\n       */\n      *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n          if (typeof plugin[name] === 'function') {\n            const state = this._pluginStateMap.get(plugin);\n            const statefulCallback = param => {\n              const statefulParam = Object.assign(Object.assign({}, param), {\n                state\n              });\n              // TODO(philipwalton): not sure why `any` is needed. It seems like\n              // this should work with `as WorkboxPluginCallbackParam[C]`.\n              return plugin[name](statefulParam);\n            };\n            yield statefulCallback;\n          }\n        }\n      }\n      /**\n       * Adds a promise to the\n       * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n       * of the event associated with the request being handled (usually a\n       * `FetchEvent`).\n       *\n       * Note: you can await\n       * {@link workbox-strategies.StrategyHandler~doneWaiting}\n       * to know when all added promises have settled.\n       *\n       * @param {Promise} promise A promise to add to the extend lifetime promises\n       *     of the event that triggered the request.\n       */\n      waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n      }\n      /**\n       * Returns a promise that resolves once all promises passed to\n       * {@link workbox-strategies.StrategyHandler~waitUntil}\n       * have settled.\n       *\n       * Note: any work done after `doneWaiting()` settles should be manually\n       * passed to an event's `waitUntil()` method (not this handler's\n       * `waitUntil()` method), otherwise the service worker thread may be killed\n       * prior to your work completing.\n       */\n      async doneWaiting() {\n        while (this._extendLifetimePromises.length) {\n          const promises = this._extendLifetimePromises.splice(0);\n          const result = await Promise.allSettled(promises);\n          const firstRejection = result.find(i => i.status === 'rejected');\n          if (firstRejection) {\n            throw firstRejection.reason;\n          }\n        }\n      }\n      /**\n       * Stops running the strategy and immediately resolves any pending\n       * `waitUntil()` promises.\n       */\n      destroy() {\n        this._handlerDeferred.resolve(null);\n      }\n      /**\n       * This method will call cacheWillUpdate on the available plugins (or use\n       * status === 200) to determine if the Response is safe and valid to cache.\n       *\n       * @param {Request} options.request\n       * @param {Response} options.response\n       * @return {Promise<Response|undefined>}\n       *\n       * @private\n       */\n      async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n          responseToCache = (await callback({\n            request: this.request,\n            response: responseToCache,\n            event: this.event\n          })) || undefined;\n          pluginsUsed = true;\n          if (!responseToCache) {\n            break;\n          }\n        }\n        if (!pluginsUsed) {\n          if (responseToCache && responseToCache.status !== 200) {\n            responseToCache = undefined;\n          }\n          {\n            if (responseToCache) {\n              if (responseToCache.status !== 200) {\n                if (responseToCache.status === 0) {\n                  logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);\n                } else {\n                  logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);\n                }\n              }\n            }\n          }\n        }\n        return responseToCache;\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An abstract base class that all other strategy classes must extend from:\n     *\n     * @memberof workbox-strategies\n     */\n    class Strategy {\n      /**\n       * Creates a new instance of the strategy and sets all documented option\n       * properties as public instance properties.\n       *\n       * Note: if a custom strategy class extends the base Strategy class and does\n       * not need more than these properties, it does not need to define its own\n       * constructor.\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] Cache name to store and retrieve\n       * requests. Defaults to the cache names provided by\n       * {@link workbox-core.cacheNames}.\n       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} [options.fetchOptions] Values passed along to the\n       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n       * `fetch()` requests made by this strategy.\n       * @param {Object} [options.matchOptions] The\n       * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n       * for any `cache.match()` or `cache.put()` calls made by this strategy.\n       */\n      constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n      }\n      /**\n       * Perform a request strategy and returns a `Promise` that will resolve with\n       * a `Response`, invoking all relevant plugin callbacks.\n       *\n       * When a strategy instance is registered with a Workbox\n       * {@link workbox-routing.Route}, this method is automatically\n       * called when the route matches.\n       *\n       * Alternatively, this method can be used in a standalone `FetchEvent`\n       * listener by passing it to `event.respondWith()`.\n       *\n       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n       *     properties listed below.\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params]\n       */\n      handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n      }\n      /**\n       * Similar to {@link workbox-strategies.Strategy~handle}, but\n       * instead of just returning a `Promise` that resolves to a `Response` it\n       * it will return an tuple of `[response, done]` promises, where the former\n       * (`response`) is equivalent to what `handle()` returns, and the latter is a\n       * Promise that will resolve once any promises that were added to\n       * `event.waitUntil()` as part of performing the strategy have completed.\n       *\n       * You can await the `done` promise to ensure any extra work performed by\n       * the strategy (usually caching responses) completes successfully.\n       *\n       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n       *     properties listed below.\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params]\n       * @return {Array<Promise>} A tuple of [response, done]\n       *     promises that can be used to determine when the response resolves as\n       *     well as when the handler has completed all its work.\n       */\n      handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n          options = {\n            event: options,\n            request: options.request\n          };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, {\n          event,\n          request,\n          params\n        });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n      }\n      async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', {\n          event,\n          request\n        });\n        let response = undefined;\n        try {\n          response = await this._handle(request, handler);\n          // The \"official\" Strategy subclasses all throw this error automatically,\n          // but in case a third-party Strategy doesn't, ensure that we have a\n          // consistent failure when there's no response or an error response.\n          if (!response || response.type === 'error') {\n            throw new WorkboxError('no-response', {\n              url: request.url\n            });\n          }\n        } catch (error) {\n          if (error instanceof Error) {\n            for (const callback of handler.iterateCallbacks('handlerDidError')) {\n              response = await callback({\n                error,\n                event,\n                request\n              });\n              if (response) {\n                break;\n              }\n            }\n          }\n          if (!response) {\n            throw error;\n          } else {\n            logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);\n          }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n          response = await callback({\n            event,\n            request,\n            response\n          });\n        }\n        return response;\n      }\n      async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n          response = await responseDone;\n        } catch (error) {\n          // Ignore errors, as response errors should be caught via the `response`\n          // promise above. The `done` promise will only throw for errors in\n          // promises passed to `handler.waitUntil()`.\n        }\n        try {\n          await handler.runCallbacks('handlerDidRespond', {\n            event,\n            request,\n            response\n          });\n          await handler.doneWaiting();\n        } catch (waitUntilError) {\n          if (waitUntilError instanceof Error) {\n            error = waitUntilError;\n          }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n          event,\n          request,\n          response,\n          error: error\n        });\n        handler.destroy();\n        if (error) {\n          throw error;\n        }\n      }\n    }\n    /**\n     * Classes extending the `Strategy` based class should implement this method,\n     * and leverage the {@link workbox-strategies.StrategyHandler}\n     * arg to perform all fetching and cache logic, which will ensure all relevant\n     * cache, cache options, fetch options and plugins are used (per the current\n     * strategy instance).\n     *\n     * @name _handle\n     * @instance\n     * @abstract\n     * @function\n     * @param {Request} request\n     * @param {workbox-strategies.StrategyHandler} handler\n     * @return {Promise<Response>}\n     *\n     * @memberof workbox-strategies.Strategy\n     */\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const messages = {\n      strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,\n      printFinalResponse: response => {\n        if (response) {\n          logger.groupCollapsed(`View the final response here.`);\n          logger.log(response || '[No response returned]');\n          logger.groupEnd();\n        }\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)\n     * request strategy.\n     *\n     * A cache first strategy is useful for assets that have been revisioned,\n     * such as URLs like `/styles/example.a8f5f1.css`, since they\n     * can be cached for long periods of time.\n     *\n     * If the network request fails, and there is no cache match, this will throw\n     * a `WorkboxError` exception.\n     *\n     * @extends workbox-strategies.Strategy\n     * @memberof workbox-strategies\n     */\n    class CacheFirst extends Strategy {\n      /**\n       * @private\n       * @param {Request|string} request A request to run this strategy for.\n       * @param {workbox-strategies.StrategyHandler} handler The event that\n       *     triggered the request.\n       * @return {Promise<Response>}\n       */\n      async _handle(request, handler) {\n        const logs = [];\n        {\n          finalAssertExports.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: this.constructor.name,\n            funcName: 'makeRequest',\n            paramName: 'request'\n          });\n        }\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (!response) {\n          {\n            logs.push(`No response found in the '${this.cacheName}' cache. ` + `Will respond with a network request.`);\n          }\n          try {\n            response = await handler.fetchAndCachePut(request);\n          } catch (err) {\n            if (err instanceof Error) {\n              error = err;\n            }\n          }\n          {\n            if (response) {\n              logs.push(`Got response from network.`);\n            } else {\n              logs.push(`Unable to get a response from the network.`);\n            }\n          }\n        } else {\n          {\n            logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n          }\n        }\n        {\n          logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n          for (const log of logs) {\n            logger.log(log);\n          }\n          messages.printFinalResponse(response);\n          logger.groupEnd();\n        }\n        if (!response) {\n          throw new WorkboxError('no-response', {\n            url: request.url,\n            error\n          });\n        }\n        return response;\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Claim any currently available clients once the service worker\n     * becomes active. This is normally used in conjunction with `skipWaiting()`.\n     *\n     * @memberof workbox-core\n     */\n    function clientsClaim() {\n      self.addEventListener('activate', () => self.clients.claim());\n    }\n\n    /*\n      Copyright 2020 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A utility method that makes it easier to use `event.waitUntil` with\n     * async functions and return the result.\n     *\n     * @param {ExtendableEvent} event\n     * @param {Function} asyncFn\n     * @return {Function}\n     * @private\n     */\n    function waitUntil(event, asyncFn) {\n      const returnPromise = asyncFn();\n      event.waitUntil(returnPromise);\n      return returnPromise;\n    }\n\n    // @ts-ignore\n    try {\n      self['workbox:precaching:7.3.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    // Name of the search parameter used to store revision info.\n    const REVISION_SEARCH_PARAM = '__WB_REVISION__';\n    /**\n     * Converts a manifest entry into a versioned URL suitable for precaching.\n     *\n     * @param {Object|string} entry\n     * @return {string} A URL with versioning info.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function createCacheKey(entry) {\n      if (!entry) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', {\n          entry\n        });\n      }\n      // If a precache manifest entry is a string, it's assumed to be a versioned\n      // URL, like '/app.abcd1234.js'. Return as-is.\n      if (typeof entry === 'string') {\n        const urlObject = new URL(entry, location.href);\n        return {\n          cacheKey: urlObject.href,\n          url: urlObject.href\n        };\n      }\n      const {\n        revision,\n        url\n      } = entry;\n      if (!url) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', {\n          entry\n        });\n      }\n      // If there's just a URL and no revision, then it's also assumed to be a\n      // versioned URL.\n      if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n          cacheKey: urlObject.href,\n          url: urlObject.href\n        };\n      }\n      // Otherwise, construct a properly versioned URL using the custom Workbox\n      // search parameter along with the revision info.\n      const cacheKeyURL = new URL(url, location.href);\n      const originalURL = new URL(url, location.href);\n      cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n      return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href\n      };\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A plugin, designed to be used with PrecacheController, to determine the\n     * of assets that were updated (or not updated) during the install event.\n     *\n     * @private\n     */\n    class PrecacheInstallReportPlugin {\n      constructor() {\n        this.updatedURLs = [];\n        this.notUpdatedURLs = [];\n        this.handlerWillStart = async ({\n          request,\n          state\n        }) => {\n          // TODO: `state` should never be undefined...\n          if (state) {\n            state.originalRequest = request;\n          }\n        };\n        this.cachedResponseWillBeUsed = async ({\n          event,\n          state,\n          cachedResponse\n        }) => {\n          if (event.type === 'install') {\n            if (state && state.originalRequest && state.originalRequest instanceof Request) {\n              // TODO: `state` should never be undefined...\n              const url = state.originalRequest.url;\n              if (cachedResponse) {\n                this.notUpdatedURLs.push(url);\n              } else {\n                this.updatedURLs.push(url);\n              }\n            }\n          }\n          return cachedResponse;\n        };\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A plugin, designed to be used with PrecacheController, to translate URLs into\n     * the corresponding cache key, based on the current revision info.\n     *\n     * @private\n     */\n    class PrecacheCacheKeyPlugin {\n      constructor({\n        precacheController\n      }) {\n        this.cacheKeyWillBeUsed = async ({\n          request,\n          params\n        }) => {\n          // Params is type any, can't change right now.\n          /* eslint-disable */\n          const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);\n          /* eslint-enable */\n          return cacheKey ? new Request(cacheKey, {\n            headers: request.headers\n          }) : request;\n        };\n        this._precacheController = precacheController;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} groupTitle\n     * @param {Array<string>} deletedURLs\n     *\n     * @private\n     */\n    const logGroup = (groupTitle, deletedURLs) => {\n      logger.groupCollapsed(groupTitle);\n      for (const url of deletedURLs) {\n        logger.log(url);\n      }\n      logger.groupEnd();\n    };\n    /**\n     * @param {Array<string>} deletedURLs\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function printCleanupDetails(deletedURLs) {\n      const deletionCount = deletedURLs.length;\n      if (deletionCount > 0) {\n        logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n        logGroup('Deleted Cache Requests', deletedURLs);\n        logger.groupEnd();\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} groupTitle\n     * @param {Array<string>} urls\n     *\n     * @private\n     */\n    function _nestedGroup(groupTitle, urls) {\n      if (urls.length === 0) {\n        return;\n      }\n      logger.groupCollapsed(groupTitle);\n      for (const url of urls) {\n        logger.log(url);\n      }\n      logger.groupEnd();\n    }\n    /**\n     * @param {Array<string>} urlsToPrecache\n     * @param {Array<string>} urlsAlreadyPrecached\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n      const precachedCount = urlsToPrecache.length;\n      const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n      if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n        if (alreadyPrecachedCount > 0) {\n          message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n        }\n        logger.groupCollapsed(message);\n        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n        logger.groupEnd();\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let supportStatus;\n    /**\n     * A utility function that determines whether the current browser supports\n     * constructing a new `Response` from a `response.body` stream.\n     *\n     * @return {boolean} `true`, if the current browser can successfully\n     *     construct a `Response` from a `response.body` stream, `false` otherwise.\n     *\n     * @private\n     */\n    function canConstructResponseFromBodyStream() {\n      if (supportStatus === undefined) {\n        const testResponse = new Response('');\n        if ('body' in testResponse) {\n          try {\n            new Response(testResponse.body);\n            supportStatus = true;\n          } catch (error) {\n            supportStatus = false;\n          }\n        }\n        supportStatus = false;\n      }\n      return supportStatus;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Allows developers to copy a response and modify its `headers`, `status`,\n     * or `statusText` values (the values settable via a\n     * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n     * object in the constructor).\n     * To modify these values, pass a function as the second argument. That\n     * function will be invoked with a single object with the response properties\n     * `{headers, status, statusText}`. The return value of this function will\n     * be used as the `ResponseInit` for the new `Response`. To change the values\n     * either modify the passed parameter(s) and return it, or return a totally\n     * new object.\n     *\n     * This method is intentionally limited to same-origin responses, regardless of\n     * whether CORS was used or not.\n     *\n     * @param {Response} response\n     * @param {Function} modifier\n     * @memberof workbox-core\n     */\n    async function copyResponse(response, modifier) {\n      let origin = null;\n      // If response.url isn't set, assume it's cross-origin and keep origin null.\n      if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n      }\n      if (origin !== self.location.origin) {\n        throw new WorkboxError('cross-origin-copy-response', {\n          origin\n        });\n      }\n      const clonedResponse = response.clone();\n      // Create a fresh `ResponseInit` object by cloning the headers.\n      const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText\n      };\n      // Apply any user modifications.\n      const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n      // Create the new response from the body stream and `ResponseInit`\n      // modifications. Note: not all browsers support the Response.body stream,\n      // so fall back to reading the entire body into memory as a blob.\n      const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();\n      return new Response(body, modifiedResponseInit);\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A {@link workbox-strategies.Strategy} implementation\n     * specifically designed to work with\n     * {@link workbox-precaching.PrecacheController}\n     * to both cache and fetch precached assets.\n     *\n     * Note: an instance of this class is created automatically when creating a\n     * `PrecacheController`; it's generally not necessary to create this yourself.\n     *\n     * @extends workbox-strategies.Strategy\n     * @memberof workbox-precaching\n     */\n    class PrecacheStrategy extends Strategy {\n      /**\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] Cache name to store and retrieve\n       * requests. Defaults to the cache names provided by\n       * {@link workbox-core.cacheNames}.\n       * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} [options.fetchOptions] Values passed along to the\n       * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n       * of all fetch() requests made by this strategy.\n       * @param {Object} [options.matchOptions] The\n       * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n       * for any `cache.match()` or `cache.put()` calls made by this strategy.\n       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n       * get the response from the network if there's a precache miss.\n       */\n      constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n      }\n      /**\n       * @private\n       * @param {Request|string} request A request to run this strategy for.\n       * @param {workbox-strategies.StrategyHandler} handler The event that\n       *     triggered the request.\n       * @return {Promise<Response>}\n       */\n      async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n          return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n          return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n      }\n      async _handleFetch(request, handler) {\n        let response;\n        const params = handler.params || {};\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n          {\n            logger.warn(`The precached response for ` + `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` + `found. Falling back to the network.`);\n          }\n          const integrityInManifest = params.integrity;\n          const integrityInRequest = request.integrity;\n          const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n          // Do not add integrity if the original request is no-cors\n          // See https://github.com/GoogleChrome/workbox/issues/3096\n          response = await handler.fetch(new Request(request, {\n            integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined\n          }));\n          // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n          // that the response matches the precache manifest's expectations,\n          // and there's either a) no integrity property in the incoming request\n          // or b) there is an integrity, and it matches the precache manifest.\n          // See https://github.com/GoogleChrome/workbox/issues/2858\n          // Also if the original request users no-cors we don't use integrity.\n          // See https://github.com/GoogleChrome/workbox/issues/3096\n          if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {\n            this._useDefaultCacheabilityPluginIfNeeded();\n            const wasCached = await handler.cachePut(request, response.clone());\n            {\n              if (wasCached) {\n                logger.log(`A response for ${getFriendlyURL(request.url)} ` + `was used to \"repair\" the precache.`);\n              }\n            }\n          }\n        } else {\n          // This shouldn't normally happen, but there are edge cases:\n          // https://github.com/GoogleChrome/workbox/issues/1441\n          throw new WorkboxError('missing-precache-entry', {\n            cacheName: this.cacheName,\n            url: request.url\n          });\n        }\n        {\n          const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n          // Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n          logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n          logger.groupCollapsed(`View request details here.`);\n          logger.log(request);\n          logger.groupEnd();\n          logger.groupCollapsed(`View response details here.`);\n          logger.log(response);\n          logger.groupEnd();\n          logger.groupEnd();\n        }\n        return response;\n      }\n      async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n          // Throwing here will lead to the `install` handler failing, which\n          // we want to do if *any* of the responses aren't safe to cache.\n          throw new WorkboxError('bad-precaching-response', {\n            url: request.url,\n            status: response.status\n          });\n        }\n        return response;\n      }\n      /**\n       * This method is complex, as there a number of things to account for:\n       *\n       * The `plugins` array can be set at construction, and/or it might be added to\n       * to at any time before the strategy is used.\n       *\n       * At the time the strategy is used (i.e. during an `install` event), there\n       * needs to be at least one plugin that implements `cacheWillUpdate` in the\n       * array, other than `copyRedirectedCacheableResponsesPlugin`.\n       *\n       * - If this method is called and there are no suitable `cacheWillUpdate`\n       * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n       *\n       * - If this method is called and there is exactly one `cacheWillUpdate`, then\n       * we don't have to do anything (this might be a previously added\n       * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n       *\n       * - If this method is called and there is more than one `cacheWillUpdate`,\n       * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n       * we need to remove it. (This situation is unlikely, but it could happen if\n       * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n       * and then later on after manually adding a custom `cacheWillUpdate`.)\n       *\n       * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n       *\n       * @private\n       */\n      _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n          // Ignore the copy redirected plugin when determining what to do.\n          if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n            continue;\n          }\n          // Save the default plugin's index, in case it needs to be removed.\n          if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n            defaultPluginIndex = index;\n          }\n          if (plugin.cacheWillUpdate) {\n            cacheWillUpdatePluginCount++;\n          }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n          this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n          // Only remove the default plugin; multiple custom plugins are allowed.\n          this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n      }\n    }\n    PrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n      async cacheWillUpdate({\n        response\n      }) {\n        if (!response || response.status >= 400) {\n          return null;\n        }\n        return response;\n      }\n    };\n    PrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n      async cacheWillUpdate({\n        response\n      }) {\n        return response.redirected ? await copyResponse(response) : response;\n      }\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Performs efficient precaching of assets.\n     *\n     * @memberof workbox-precaching\n     */\n    class PrecacheController {\n      /**\n       * Create a new PrecacheController.\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] The cache to use for precaching.\n       * @param {string} [options.plugins] Plugins to use when precaching as well\n       * as responding to fetch events for precached assets.\n       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n       * get the response from the network if there's a precache miss.\n       */\n      constructor({\n        cacheName,\n        plugins = [],\n        fallbackToNetwork = true\n      } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n          cacheName: cacheNames.getPrecacheName(cacheName),\n          plugins: [...plugins, new PrecacheCacheKeyPlugin({\n            precacheController: this\n          })],\n          fallbackToNetwork\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n      }\n      /**\n       * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n       * used to cache assets and respond to fetch events.\n       */\n      get strategy() {\n        return this._strategy;\n      }\n      /**\n       * Adds items to the precache list, removing any duplicates and\n       * stores the files in the\n       * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n       * worker installs.\n       *\n       * This method can be called multiple times.\n       *\n       * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n       */\n      precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n          self.addEventListener('install', this.install);\n          self.addEventListener('activate', this.activate);\n          this._installAndActiveListenersAdded = true;\n        }\n      }\n      /**\n       * This method will add items to the precache list, removing duplicates\n       * and ensuring the information is valid.\n       *\n       * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n       *     Array of entries to precache.\n       */\n      addToCacheList(entries) {\n        {\n          finalAssertExports.isArray(entries, {\n            moduleName: 'workbox-precaching',\n            className: 'PrecacheController',\n            funcName: 'addToCacheList',\n            paramName: 'entries'\n          });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n          // See https://github.com/GoogleChrome/workbox/issues/2259\n          if (typeof entry === 'string') {\n            urlsToWarnAbout.push(entry);\n          } else if (entry && entry.revision === undefined) {\n            urlsToWarnAbout.push(entry.url);\n          }\n          const {\n            cacheKey,\n            url\n          } = createCacheKey(entry);\n          const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n            throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n              firstEntry: this._urlsToCacheKeys.get(url),\n              secondEntry: cacheKey\n            });\n          }\n          if (typeof entry !== 'string' && entry.integrity) {\n            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                url\n              });\n            }\n            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n          }\n          this._urlsToCacheKeys.set(url, cacheKey);\n          this._urlsToCacheModes.set(url, cacheMode);\n          if (urlsToWarnAbout.length > 0) {\n            const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n            {\n              logger.warn(warningMessage);\n            }\n          }\n        }\n      }\n      /**\n       * Precaches new and updated assets. Call this method from the service worker\n       * install event.\n       *\n       * Note: this method calls `event.waitUntil()` for you, so you do not need\n       * to call it yourself in your event handlers.\n       *\n       * @param {ExtendableEvent} event\n       * @return {Promise<workbox-precaching.InstallResult>}\n       */\n      install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n          const installReportPlugin = new PrecacheInstallReportPlugin();\n          this.strategy.plugins.push(installReportPlugin);\n          // Cache entries one at a time.\n          // See https://github.com/GoogleChrome/workbox/issues/2528\n          for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            const cacheMode = this._urlsToCacheModes.get(url);\n            const request = new Request(url, {\n              integrity,\n              cache: cacheMode,\n              credentials: 'same-origin'\n            });\n            await Promise.all(this.strategy.handleAll({\n              params: {\n                cacheKey\n              },\n              request,\n              event\n            }));\n          }\n          const {\n            updatedURLs,\n            notUpdatedURLs\n          } = installReportPlugin;\n          {\n            printInstallDetails(updatedURLs, notUpdatedURLs);\n          }\n          return {\n            updatedURLs,\n            notUpdatedURLs\n          };\n        });\n      }\n      /**\n       * Deletes assets that are no longer present in the current precache manifest.\n       * Call this method from the service worker activate event.\n       *\n       * Note: this method calls `event.waitUntil()` for you, so you do not need\n       * to call it yourself in your event handlers.\n       *\n       * @param {ExtendableEvent} event\n       * @return {Promise<workbox-precaching.CleanupResult>}\n       */\n      activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n          const cache = await self.caches.open(this.strategy.cacheName);\n          const currentlyCachedRequests = await cache.keys();\n          const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n          const deletedURLs = [];\n          for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n              await cache.delete(request);\n              deletedURLs.push(request.url);\n            }\n          }\n          {\n            printCleanupDetails(deletedURLs);\n          }\n          return {\n            deletedURLs\n          };\n        });\n      }\n      /**\n       * Returns a mapping of a precached URL to the corresponding cache key, taking\n       * into account the revision information for the URL.\n       *\n       * @return {Map<string, string>} A URL to cache key mapping.\n       */\n      getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n      }\n      /**\n       * Returns a list of all the URLs that have been precached by the current\n       * service worker.\n       *\n       * @return {Array<string>} The precached URLs.\n       */\n      getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n      }\n      /**\n       * Returns the cache key used for storing a given URL. If that URL is\n       * unversioned, like `/index.html', then the cache key will be the original\n       * URL with a search parameter appended to it.\n       *\n       * @param {string} url A URL whose cache key you want to look up.\n       * @return {string} The versioned URL that corresponds to a cache key\n       * for the original URL, or undefined if that URL isn't precached.\n       */\n      getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n      }\n      /**\n       * @param {string} url A cache key whose SRI you want to look up.\n       * @return {string} The subresource integrity associated with the cache key,\n       * or undefined if it's not set.\n       */\n      getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n      }\n      /**\n       * This acts as a drop-in replacement for\n       * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n       * with the following differences:\n       *\n       * - It knows what the name of the precache is, and only checks in that cache.\n       * - It allows you to pass in an \"original\" URL without versioning parameters,\n       * and it will automatically look up the correct cache key for the currently\n       * active revision of that URL.\n       *\n       * E.g., `matchPrecache('index.html')` will find the correct precached\n       * response for the currently active service worker, even if the actual cache\n       * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n       *\n       * @param {string|Request} request The key (without revisioning parameters)\n       * to look up in the precache.\n       * @return {Promise<Response|undefined>}\n       */\n      async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n          const cache = await self.caches.open(this.strategy.cacheName);\n          return cache.match(cacheKey);\n        }\n        return undefined;\n      }\n      /**\n       * Returns a function that looks up `url` in the precache (taking into\n       * account revision information), and returns the corresponding `Response`.\n       *\n       * @param {string} url The precached URL which will be used to lookup the\n       * `Response`.\n       * @return {workbox-routing~handlerCallback}\n       */\n      createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n          throw new WorkboxError('non-precached-url', {\n            url\n          });\n        }\n        return options => {\n          options.request = new Request(url);\n          options.params = Object.assign({\n            cacheKey\n          }, options.params);\n          return this.strategy.handle(options);\n        };\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let precacheController;\n    /**\n     * @return {PrecacheController}\n     * @private\n     */\n    const getOrCreatePrecacheController = () => {\n      if (!precacheController) {\n        precacheController = new PrecacheController();\n      }\n      return precacheController;\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Removes any URL search parameters that should be ignored.\n     *\n     * @param {URL} urlObject The original URL.\n     * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n     * each search parameter name. Matches mean that the search parameter should be\n     * ignored.\n     * @return {URL} The URL with any ignored search parameters removed.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {\n      // Convert the iterable into an array at the start of the loop to make sure\n      // deletion doesn't mess up iteration.\n      for (const paramName of [...urlObject.searchParams.keys()]) {\n        if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n          urlObject.searchParams.delete(paramName);\n        }\n      }\n      return urlObject;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Generator function that yields possible variations on the original URL to\n     * check, one at a time.\n     *\n     * @param {string} url\n     * @param {Object} options\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function* generateURLVariations(url, {\n      ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],\n      directoryIndex = 'index.html',\n      cleanURLs = true,\n      urlManipulation\n    } = {}) {\n      const urlObject = new URL(url, location.href);\n      urlObject.hash = '';\n      yield urlObject.href;\n      const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n      yield urlWithoutIgnoredParams.href;\n      if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n      }\n      if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += '.html';\n        yield cleanURL.href;\n      }\n      if (urlManipulation) {\n        const additionalURLs = urlManipulation({\n          url: urlObject\n        });\n        for (const urlToAttempt of additionalURLs) {\n          yield urlToAttempt.href;\n        }\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A subclass of {@link workbox-routing.Route} that takes a\n     * {@link workbox-precaching.PrecacheController}\n     * instance and uses it to match incoming requests and handle fetching\n     * responses from the precache.\n     *\n     * @memberof workbox-precaching\n     * @extends workbox-routing.Route\n     */\n    class PrecacheRoute extends Route {\n      /**\n       * @param {PrecacheController} precacheController A `PrecacheController`\n       * instance used to both match requests and respond to fetch events.\n       * @param {Object} [options] Options to control how requests are matched\n       * against the list of precached URLs.\n       * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n       * check cache entries for a URLs ending with '/' to see if there is a hit when\n       * appending the `directoryIndex` value.\n       * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n       * array of regex's to remove search params when looking for a cache match.\n       * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n       * check the cache for the URL with a `.html` added to the end of the end.\n       * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n       * This is a function that should take a URL and return an array of\n       * alternative URLs that should be checked for precache matches.\n       */\n      constructor(precacheController, options) {\n        const match = ({\n          request\n        }) => {\n          const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n          for (const possibleURL of generateURLVariations(request.url, options)) {\n            const cacheKey = urlsToCacheKeys.get(possibleURL);\n            if (cacheKey) {\n              const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n              return {\n                cacheKey,\n                integrity\n              };\n            }\n          }\n          {\n            logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));\n          }\n          return;\n        };\n        super(match, precacheController.strategy);\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Add a `fetch` listener to the service worker that will\n     * respond to\n     * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n     * with precached assets.\n     *\n     * Requests for assets that aren't precached, the `FetchEvent` will not be\n     * responded to, allowing the event to fall through to other `fetch` event\n     * listeners.\n     *\n     * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}\n     * options.\n     *\n     * @memberof workbox-precaching\n     */\n    function addRoute(options) {\n      const precacheController = getOrCreatePrecacheController();\n      const precacheRoute = new PrecacheRoute(precacheController, options);\n      registerRoute(precacheRoute);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * Please note: This method **will not** serve any of the cached files for you.\n     * It only precaches files. To respond to a network request you call\n     * {@link workbox-precaching.addRoute}.\n     *\n     * If you have a single array of files to precache, you can just call\n     * {@link workbox-precaching.precacheAndRoute}.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     *\n     * @memberof workbox-precaching\n     */\n    function precache(entries) {\n      const precacheController = getOrCreatePrecacheController();\n      precacheController.precache(entries);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This method will add entries to the precache list and add a route to\n     * respond to fetch events.\n     *\n     * This is a convenience method that will call\n     * {@link workbox-precaching.precache} and\n     * {@link workbox-precaching.addRoute} in a single call.\n     *\n     * @param {Array<Object|string>} entries Array of entries to precache.\n     * @param {Object} [options] See the\n     * {@link workbox-precaching.PrecacheRoute} options.\n     *\n     * @memberof workbox-precaching\n     */\n    function precacheAndRoute(entries, options) {\n      precache(entries);\n      addRoute(options);\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const SUBSTRING_TO_FIND = '-precache-';\n    /**\n     * Cleans up incompatible precaches that were created by older versions of\n     * Workbox, by a service worker registered under the current scope.\n     *\n     * This is meant to be called as part of the `activate` event.\n     *\n     * This should be safe to use as long as you don't include `substringToFind`\n     * (defaulting to `-precache-`) in your non-precache cache names.\n     *\n     * @param {string} currentPrecacheName The cache name currently in use for\n     * precaching. This cache won't be deleted.\n     * @param {string} [substringToFind='-precache-'] Cache names which include this\n     * substring will be deleted (excluding `currentPrecacheName`).\n     * @return {Array<string>} A list of all the cache names that were deleted.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {\n      const cacheNames = await self.caches.keys();\n      const cacheNamesToDelete = cacheNames.filter(cacheName => {\n        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n      });\n      await Promise.all(cacheNamesToDelete.map(cacheName => self.caches.delete(cacheName)));\n      return cacheNamesToDelete;\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds an `activate` event listener which will clean up incompatible\n     * precaches that were created by older versions of Workbox.\n     *\n     * @memberof workbox-precaching\n     */\n    function cleanupOutdatedCaches() {\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('activate', event => {\n        const cacheName = cacheNames.getPrecacheName();\n        event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {\n          {\n            if (cachesDeleted.length > 0) {\n              logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);\n            }\n          }\n        }));\n      });\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * NavigationRoute makes it easy to create a\n     * {@link workbox-routing.Route} that matches for browser\n     * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\n     *\n     * It will only match incoming Requests whose\n     * {@link https://fetch.spec.whatwg.org/#concept-request-mode|mode}\n     * is set to `navigate`.\n     *\n     * You can optionally only apply this route to a subset of navigation requests\n     * by using one or both of the `denylist` and `allowlist` parameters.\n     *\n     * @memberof workbox-routing\n     * @extends workbox-routing.Route\n     */\n    class NavigationRoute extends Route {\n      /**\n       * If both `denylist` and `allowlist` are provided, the `denylist` will\n       * take precedence and the request will not match this route.\n       *\n       * The regular expressions in `allowlist` and `denylist`\n       * are matched against the concatenated\n       * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\n       * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\n       * portions of the requested URL.\n       *\n       * *Note*: These RegExps may be evaluated against every destination URL during\n       * a navigation. Avoid using\n       * [complex RegExps](https://github.com/GoogleChrome/workbox/issues/3077),\n       * or else your users may see delays when navigating your site.\n       *\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {Object} options\n       * @param {Array<RegExp>} [options.denylist] If any of these patterns match,\n       * the route will not handle the request (even if a allowlist RegExp matches).\n       * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns\n       * match the URL's pathname and search parameter, the route will handle the\n       * request (assuming the denylist doesn't match).\n       */\n      constructor(handler, {\n        allowlist = [/./],\n        denylist = []\n      } = {}) {\n        {\n          finalAssertExports.isArrayOfClass(allowlist, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'NavigationRoute',\n            funcName: 'constructor',\n            paramName: 'options.allowlist'\n          });\n          finalAssertExports.isArrayOfClass(denylist, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'NavigationRoute',\n            funcName: 'constructor',\n            paramName: 'options.denylist'\n          });\n        }\n        super(options => this._match(options), handler);\n        this._allowlist = allowlist;\n        this._denylist = denylist;\n      }\n      /**\n       * Routes match handler.\n       *\n       * @param {Object} options\n       * @param {URL} options.url\n       * @param {Request} options.request\n       * @return {boolean}\n       *\n       * @private\n       */\n      _match({\n        url,\n        request\n      }) {\n        if (request && request.mode !== 'navigate') {\n          return false;\n        }\n        const pathnameAndSearch = url.pathname + url.search;\n        for (const regExp of this._denylist) {\n          if (regExp.test(pathnameAndSearch)) {\n            {\n              logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL matches this denylist pattern: ` + `${regExp.toString()}`);\n            }\n            return false;\n          }\n        }\n        if (this._allowlist.some(regExp => regExp.test(pathnameAndSearch))) {\n          {\n            logger.debug(`The navigation route ${pathnameAndSearch} ` + `is being used.`);\n          }\n          return true;\n        }\n        {\n          logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL being navigated to doesn't ` + `match the allowlist.`);\n        }\n        return false;\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Helper function that calls\n     * {@link PrecacheController#createHandlerBoundToURL} on the default\n     * {@link PrecacheController} instance.\n     *\n     * If you are creating your own {@link PrecacheController}, then call the\n     * {@link PrecacheController#createHandlerBoundToURL} on that instance,\n     * instead of using this function.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {workbox-routing~handlerCallback}\n     *\n     * @memberof workbox-precaching\n     */\n    function createHandlerBoundToURL(url) {\n      const precacheController = getOrCreatePrecacheController();\n      return precacheController.createHandlerBoundToURL(url);\n    }\n\n    exports.CacheFirst = CacheFirst;\n    exports.ExpirationPlugin = ExpirationPlugin;\n    exports.NavigationRoute = NavigationRoute;\n    exports.cleanupOutdatedCaches = cleanupOutdatedCaches;\n    exports.clientsClaim = clientsClaim;\n    exports.createHandlerBoundToURL = createHandlerBoundToURL;\n    exports.precacheAndRoute = precacheAndRoute;\n    exports.registerRoute = registerRoute;\n\n}));\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\App.jsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n  53 |     window.addEventListener('keydown', handleKeyDown);\n  54 |     if (activeFileId && showTasks) {\n> 55 |       setShowTasks(false);\n     |       ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  56 |     }\n  57 |     return () => window.removeEventListener('keydown', handleKeyDown);\n  58 |   }, [activeFileId, showTasks, disconnectWorkspace]);","line":55,"column":7,"nodeType":null,"endLine":55,"endColumn":19},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setActiveFileId'. Either include it or remove the dependency array.","line":58,"column":6,"nodeType":"ArrayExpression","endLine":58,"endColumn":52,"suggestions":[{"desc":"Update the dependencies array to be: [activeFileId, showTasks, disconnectWorkspace, setActiveFileId]","fix":{"range":[2066,2112],"text":"[activeFileId, showTasks, disconnectWorkspace, setActiveFileId]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { useNotes } from './context/NotesContext';\nimport Sidebar from './components/Sidebar';\nimport Editor from './components/Editor';\nimport HelpModal from './components/HelpModal';\nimport GlobalTasks from './components/GlobalTasks';\nimport WelcomeScreen from './components/WelcomeScreen';\nimport { Menu, Sun, Moon } from 'lucide-react';\n\nfunction App() {\n  const { isInitializing, activeFileId, setActiveFileId, workspaceHandle, disconnectWorkspace } = useNotes();\n  const [sidebarOpen, setSidebarOpen] = useState(false);\n  const [helpOpen, setHelpOpen] = useState(false);\n  const [showTasks, setShowTasks] = useState(false);\n\n  const [isDarkMode, setIsDarkMode] = useState(() => {\n    const saved = localStorage.getItem('theme');\n    if (saved) return saved === 'dark';\n    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n  });\n\n  useEffect(() => {\n    if (isDarkMode) {\n      document.documentElement.classList.add('dark');\n      localStorage.setItem('theme', 'dark');\n    } else {\n      document.documentElement.classList.remove('dark');\n      localStorage.setItem('theme', 'light');\n    }\n  }, [isDarkMode]);\n\n  useEffect(() => {\n    const handleKeyDown = (e) => {\n      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || (e.target.closest('.ProseMirror') && !e.altKey)) {\n        return;\n      }\n\n      if (e.altKey && e.key === '/') {\n        e.preventDefault();\n        setHelpOpen(prev => !prev);\n      }\n      if (e.altKey && !e.shiftKey && e.key.toLowerCase() === 'h') {\n        e.preventDefault();\n        setActiveFileId(null);\n        setShowTasks(false);\n        setSidebarOpen(false);\n      }\n      if (e.altKey && !e.shiftKey && e.key.toLowerCase() === 'w') {\n        e.preventDefault();\n        disconnectWorkspace();\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    if (activeFileId && showTasks) {\n      setShowTasks(false);\n    }\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [activeFileId, showTasks, disconnectWorkspace]);\n\n  if (isInitializing) {\n    return (\n      <div className=\"app-container\" style={{ alignItems: 'center', justifyContent: 'center' }}>\n        <p style={{ color: 'var(--text-tertiary)' }}>Loading your workspace...</p>\n      </div>\n    );\n  }\n\n  if (!workspaceHandle) {\n    return (\n      <div className=\"app-container\" style={{ height: '100dvh' }}>\n        <WelcomeScreen openHelp={() => setHelpOpen(true)} />\n        <div style={{ position: 'absolute', top: 24, right: 24, zIndex: 100 }}>\n          <button\n            className=\"icon-button\"\n            onClick={() => setIsDarkMode(!isDarkMode)}\n            title=\"Toggle Theme\"\n            style={{ background: 'var(--bg-secondary)', border: '1px solid var(--border-color)' }}\n          >\n            {isDarkMode ? <Sun size={20} /> : <Moon size={20} />}\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"app-container\">\n      <div\n        className={`sidebar-overlay ${sidebarOpen ? 'open' : ''}`}\n        onClick={() => setSidebarOpen(false)}\n      ></div>\n\n      <Sidebar\n        isOpen={sidebarOpen}\n        onClose={() => setSidebarOpen(false)}\n        onOpenHelp={() => setHelpOpen(true)}\n        setShowTasks={() => { setShowTasks(true); setActiveFileId(null); setSidebarOpen(false); }}\n        onGoHome={() => { setActiveFileId(null); setShowTasks(false); setSidebarOpen(false); }}\n      />\n      <HelpModal isOpen={helpOpen} onClose={() => setHelpOpen(false)} />\n\n      <main className=\"main-area\">\n        <div className=\"editor-header\" style={{ display: 'flex', gap: '16px', borderBottom: activeFileId ? '1px solid var(--border-color)' : 'none', justifyContent: 'space-between', alignItems: 'center' }}>\n          <div style={{ display: 'flex', gap: '16px', alignItems: 'center' }}>\n            <button\n              className=\"icon-button mobile-menu-btn\"\n              onClick={() => setSidebarOpen(true)}\n              style={{ display: 'none' }}\n            >\n              <Menu size={20} />\n            </button>\n            <style>{`\n              @media (max-width: 768px) {\n                .mobile-menu-btn { display: flex !important; }\n              }\n            `}</style>\n          </div>\n\n          <button\n            className=\"icon-button\"\n            onClick={() => setIsDarkMode(!isDarkMode)}\n            title=\"Toggle Theme\"\n            style={{ marginRight: '16px' }}\n          >\n            {isDarkMode ? <Sun size={20} /> : <Moon size={20} />}\n          </button>\n        </div>\n\n        {showTasks && <GlobalTasks />}\n        {!showTasks && activeFileId && <Editor key={activeFileId} fileId={activeFileId} />}\n        {!showTasks && !activeFileId && <WelcomeScreen openHelp={() => setHelpOpen(true)} />}\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\components\\Cheatsheet.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\components\\Editor.jsx","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\*.","line":147,"column":52,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":147,"endColumn":53,"suggestions":[{"messageId":"removeEscape","fix":{"range":[7296,7297],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[7296,7296],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\[.","line":147,"column":54,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":147,"endColumn":55,"suggestions":[{"messageId":"removeEscape","fix":{"range":[7298,7299],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[7298,7298],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'setBubbleMenu' is defined but never used.","line":206,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":206,"endColumn":58,"suggestions":[{"messageId":"removeVar","data":{"varName":"setBubbleMenu"},"fix":{"range":[10066,10081],"text":""},"desc":"Remove unused variable 'setBubbleMenu'."}]},{"ruleId":"no-dupe-keys","severity":2,"message":"Duplicate key 'parseHTML'.","line":474,"column":13,"nodeType":"ObjectExpression","messageId":"unexpected","endLine":474,"endColumn":22},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":491,"column":70,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":491,"endColumn":71,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25418,25419],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25418,25418],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":491,"column":72,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":491,"endColumn":73,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25420,25421],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25420,25420],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":491,"column":83,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":491,"endColumn":84,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25431,25432],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25431,25431],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":491,"column":85,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":491,"endColumn":86,"suggestions":[{"messageId":"removeEscape","fix":{"range":[25433,25434],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[25433,25433],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":523,"column":70,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":523,"endColumn":71,"suggestions":[{"messageId":"removeEscape","fix":{"range":[27223,27224],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[27223,27223],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":523,"column":72,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":523,"endColumn":73,"suggestions":[{"messageId":"removeEscape","fix":{"range":[27225,27226],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[27225,27225],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":523,"column":83,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":523,"endColumn":84,"suggestions":[{"messageId":"removeEscape","fix":{"range":[27236,27237],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[27236,27236],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":523,"column":85,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":523,"endColumn":86,"suggestions":[{"messageId":"removeEscape","fix":{"range":[27238,27239],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[27238,27238],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-undef","severity":2,"message":"'setForceRender' is not defined.","line":573,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":573,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'innerErr' is defined but never used.","line":612,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":612,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":653,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":653,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'slashMenuRef' is not defined.","line":708,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":708,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'slashMenuRef' is not defined.","line":709,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":709,"endColumn":44},{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":765,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":765,"endColumn":35},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":765,"column":37,"nodeType":"BlockStatement","messageId":"unexpected","endLine":765,"endColumn":40,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[38901,38902],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'file'. Either include it or remove the dependency array.","line":770,"column":8,"nodeType":"ArrayExpression","endLine":770,"endColumn":41,"suggestions":[{"desc":"Update the dependencies array to be: [fileId, nodes, editor, file.id, file]","fix":{"range":[38980,39013],"text":"[fileId, nodes, editor, file.id, file]"}}]}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\r\nimport { useNotes } from '../context/NotesContext';\r\nimport { Trash, Bold, Italic, Strikethrough, Code, Heading1, Heading2, Heading3, List, ListOrdered, Quote, CheckSquare, Link as LinkIcon, ExternalLink } from 'lucide-react';\r\n\r\n\r\nimport { useEditor, EditorContent, ReactNodeViewRenderer, NodeViewWrapper, NodeViewContent } from '@tiptap/react';\r\nimport { Node, mergeAttributes, InputRule } from '@tiptap/core';\r\nimport TurndownService from 'turndown';\r\nimport markdownit from 'markdown-it';\r\nimport StarterKit from '@tiptap/starter-kit';\r\nimport Placeholder from '@tiptap/extension-placeholder';\r\nimport TaskItem from '@tiptap/extension-task-item';\r\nimport TaskList from '@tiptap/extension-task-list';\r\nimport taskLists from 'markdown-it-task-lists';\r\nimport { parseDateString } from '../utils/dateHelpers';\r\nimport InlineDateInput from './InlineDateInput';\r\nimport CodeBlock from '@tiptap/extension-code-block';\r\nimport Link from '@tiptap/extension-link';\r\n\r\n\r\n// React Component for TaskItem Node View\r\nconst CustomTaskItemComponent = (props) => {\r\n    const { node, updateAttributes } = props;\r\n    if (!node || !node.attrs) return null;\r\n    const clearDate = (e) => {\r\n\r\n        if (e && e.stopPropagation) e.stopPropagation();\r\n        updateAttributes({ hasDate: false, date: '', hasTime: false });\r\n    };\r\n    const handleDateUpdate = (newDateUrlString, newHasTime) => {\r\n        updateAttributes({ date: newDateUrlString, hasDate: true, hasTime: newHasTime });\r\n    };\r\n    return (\r\n        <NodeViewWrapper as=\"li\" data-type=\"taskItem\" data-checked={node.attrs.checked} style={{ display: 'flex', alignItems: 'flex-start', margin: '4px 0', gap: '8px' }}>\r\n            <label contentEditable={false} style={{ marginTop: '4px', cursor: 'pointer', display: 'flex' }}>\r\n                <input\r\n                    type=\"checkbox\"\r\n                    checked={node.attrs.checked}\r\n                    onChange={e => {\r\n                        updateAttributes({ checked: e.target.checked });\r\n                    }}\r\n                    style={{ width: '16px', height: '16px', cursor: 'pointer' }}\r\n                />\r\n            </label>\r\n\r\n            <div style={{ flex: 1 }}>\r\n                <NodeViewContent as=\"div\" style={{\r\n                    textDecoration: node.attrs.checked ? 'line-through' : 'none',\r\n                    color: node.attrs.checked ? 'var(--text-tertiary)' : 'inherit',\r\n                    minHeight: '24px', outline: 'none'\r\n                }} />\r\n                {node.attrs.hasDate && (\r\n                    <div data-type=\"inline-date-badge\" contentEditable={false} style={{ marginTop: '2px', display: 'flex', alignItems: 'center', gap: '4px', userSelect: 'none' }}>\r\n\r\n                        <InlineDateInput\r\n                            initialDate={node.attrs.date}\r\n                            initialHasTime={node.attrs.hasTime}\r\n                            isChecked={node.attrs.checked}\r\n                            onDateChange={handleDateUpdate}\r\n                            onClearDate={clearDate}\r\n                        />\r\n                        <button onClick={clearDate} style={{ background: 'transparent', border: 'none', padding: '2px 4px', fontSize: '12px', color: 'var(--danger-color)', cursor: 'pointer' }} title=\"Remove Date\">Ô£ò</button>\r\n                    </div>\r\n                )}\r\n            </div>\r\n        </NodeViewWrapper>\r\n    );\r\n};\r\n\r\n// React Component for Inline Date Input\r\nconst InlineDateInputNodeView = (props) => {\r\n    const [value, setValue] = useState('');\r\n    const inputRef = useRef(null);\r\n    useEffect(() => { if (inputRef.current) setTimeout(() => inputRef.current?.focus(), 10); }, []);\r\n    const handleKeyDown = (e) => {\r\n        if (e.key === 'Tab') {\r\n            e.preventDefault();\r\n            const today = new Date();\r\n            setValue(`${String(today.getDate()).padStart(2, '0')}/${String(today.getMonth() + 1).padStart(2, '0')}/${today.getFullYear()}`);\r\n        } else if (e.key === 'Enter') {\r\n            e.preventDefault();\r\n            const { editor, getPos } = props;\r\n            if (typeof getPos !== 'function') return;\r\n            const pos = getPos();\r\n            if (pos === undefined) return;\r\n            const $pos = editor.state.doc.resolve(pos);\r\n            let taskItemNode = null;\r\n            for (let i = $pos.depth; i > 0; i--) { if ($pos.node(i).type.name === 'taskItem') { taskItemNode = $pos.node(i); break; } }\r\n            const { parsedDate, hasDate, hasTime } = parseDateString(value);\r\n            if (taskItemNode && hasDate) {\r\n                editor.chain().deleteRange({ from: pos, to: pos + 1 }).updateAttributes('taskItem', { date: parsedDate, hasDate, hasTime }).focus().run();\r\n            } else {\r\n                editor.chain().deleteRange({ from: pos, to: pos + 1 }).insertContent(`@${value}`).focus().run();\r\n            }\r\n        } else if (e.key === 'Escape') {\r\n            const { getPos } = props;\r\n            if (typeof getPos !== 'function') return;\r\n            const pos = getPos();\r\n            if (pos === undefined) return;\r\n            props.editor.chain().deleteRange({ from: pos, to: pos + 1 }).insertContent(`@${value}`).focus().run();\r\n        }\r\n\r\n    };\r\n    return (\r\n        <NodeViewWrapper as=\"span\" style={{ display: 'inline-flex', alignItems: 'center', background: 'var(--bg-accent)', borderRadius: '4px', padding: '0 4px', color: 'var(--accent-color)' }}>\r\n            <span style={{ fontWeight: 'bold', marginRight: '2px' }}>@</span>\r\n            <input ref={inputRef} type=\"text\" value={value} onChange={e => setValue(e.target.value)} onKeyDown={handleKeyDown}\r\n                style={{ border: 'none', outline: 'none', background: 'transparent', color: 'var(--accent-color)', fontFamily: 'monospace', fontSize: '0.9em', width: '17ch' }} />\r\n        </NodeViewWrapper>\r\n    );\r\n};\r\n\r\nconst md = markdownit({ html: true, linkify: true, typographer: true }).use(taskLists, { label: false });\r\n\r\nconst td = new TurndownService({\r\n    headingStyle: 'atx',\r\n    hr: '---',\r\n    bulletListMarker: '-',\r\n    codeBlockStyle: 'fenced',\r\n    blankReplacement: (content, node) => {\r\n        return node.nodeName === 'P' ? '&nbsp;\\n\\n' : (node.isBlock ? '\\n\\n' : '');\r\n    }\r\n});\r\n// Task Item serialization\r\ntd.addRule('taskItem', {\r\n    filter: (node) => node.nodeName === 'LI' && (\r\n        node.getAttribute('data-type') === 'taskItem' ||\r\n        node.classList.contains('task-list-item')\r\n    ),\r\n    replacement: (content, node) => {\r\n        const isChecked = node.getAttribute('data-checked') === 'true' ||\r\n            node.hasAttribute('checked') ||\r\n            node.classList.contains('is-checked') ||\r\n            !!node.querySelector('input[checked]') ||\r\n            !!node.querySelector('input[type=\"checkbox\"]:checked');\r\n\r\n\r\n\r\n\r\n        const date = node.getAttribute('data-date');\r\n        const hasTime = node.getAttribute('data-has-time') === 'true';\r\n\r\n        // Content should be clean text/markdown from children\r\n        let cleanContent = content.trim();\r\n\r\n        // Remove any leading/trailing list markers that might have leaked from default rules\r\n        cleanContent = cleanContent.replace(/^[\\s\\-\\*\\[\\]x]*\\s*/, '');\r\n        // Remove \"Due:\" text if added by badges\r\n        cleanContent = cleanContent.replace(/Due:\\s*[^]*?(\\n|$)/g, '').trim();\r\n\r\n        let dateString = '';\r\n        if (date) {\r\n            const formattedDate = hasTime ? date.replace('T', ' ') : date.split('T')[0];\r\n            dateString = ` @${formattedDate}`;\r\n        }\r\n\r\n        return `\\n- [${isChecked ? 'x' : ' '}] ${cleanContent}${dateString}`;\r\n    }\r\n});\r\n\r\n\r\n\r\ntd.addRule('inlineDateInput', {\r\n    filter: (node) => node.getAttribute('data-type') === 'inline-date',\r\n    replacement: (content, node) => {\r\n        const input = node.querySelector('input');\r\n        const badgeValue = node.getAttribute('data-date-value');\r\n        return `@${input ? input.value : (badgeValue || '')}`;\r\n    }\r\n});\r\n\r\n// Explicitly ignore the date badge text in Turndown\r\ntd.addRule('ignoreDateBadge', {\r\n    filter: (node) => {\r\n        // More robust filter for the date badge div\r\n        return (\r\n            (node.getAttribute('contenteditable') === 'false' && (node.innerText?.includes('Due:') || node.textContent?.includes('Due:'))) ||\r\n            node.getAttribute('data-type') === 'inline-date-badge'\r\n        );\r\n    },\r\n    replacement: () => ''\r\n});\r\n\r\ntd.addRule('fencedCodeBlock', {\r\n    filter: 'pre',\r\n    replacement: (content, node) => {\r\n        const code = node.innerText || node.textContent || '';\r\n        return `\\n\\n\\`\\`\\`\\n${code.trim()}\\n\\`\\`\\`\\n\\n`;\r\n    }\r\n});\r\n\r\nconst SLASH_OPTIONS = [\r\n    { label: 'Heading 1', icon: 'H1', command: (editor) => editor.chain().focus().toggleHeading({ level: 1 }).run() },\r\n    { label: 'Heading 2', icon: 'H2', command: (editor) => editor.chain().focus().toggleHeading({ level: 2 }).run() },\r\n    { label: 'Heading 3', icon: 'H3', command: (editor) => editor.chain().focus().toggleHeading({ level: 3 }).run() },\r\n    { label: 'Bold', icon: 'B', command: (editor) => editor.chain().focus().toggleBold().run() },\r\n    { label: 'Italic', icon: 'I', command: (editor) => editor.chain().focus().toggleItalic().run() },\r\n    { label: 'Bulleted List', icon: 'ÔÇó', command: (editor) => editor.chain().focus().toggleBulletList().run() },\r\n    { label: 'Numbered List', icon: '1.', command: (editor) => editor.chain().focus().toggleOrderedList().run() },\r\n    { label: 'Todo List', icon: 'ÔÿÉ', command: (editor) => editor.chain().focus().toggleTaskList().run() },\r\n    { label: 'Quote', icon: 'ÔÇØ', command: (editor) => editor.chain().focus().toggleBlockquote().run() },\r\n    { label: 'Code Block', icon: '</>', command: (editor) => editor.chain().focus().toggleCodeBlock().run() },\r\n    { label: 'Divider', icon: 'ÔÇö', command: (editor) => editor.chain().focus().setHorizontalRule().run() },\r\n];\r\n\r\nconst BubbleMenuUI = ({ editor, bubbleMenu, setBubbleMenu }) => {\r\n    const [, setTick] = useState(0);\r\n\r\n    useEffect(() => {\r\n        if (!editor || !bubbleMenu.isOpen) return;\r\n        const update = () => setTick(t => t + 1);\r\n        editor.on('transaction', update);\r\n        return () => editor.off('transaction', update);\r\n    }, [editor, bubbleMenu.isOpen]);\r\n\r\n    if (!bubbleMenu.isOpen || !editor || typeof bubbleMenu.top !== 'number' || typeof bubbleMenu.left !== 'number') return null;\r\n\r\n    return (\r\n        <div\r\n            className=\"custom-bubble-menu\"\r\n            style={{ position: 'fixed', top: bubbleMenu.top, left: bubbleMenu.left, zIndex: 100 }}\r\n            onMouseDown={(e) => e.preventDefault()} // Prevent stealing focus from the editor\r\n        >\r\n            <button onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()} className={editor.isActive('heading', { level: 1 }) ? 'is-active' : ''} title=\"Heading 1\"><Heading1 size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()} className={editor.isActive('heading', { level: 2 }) ? 'is-active' : ''} title=\"Heading 2\"><Heading2 size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()} className={editor.isActive('heading', { level: 3 }) ? 'is-active' : ''} title=\"Heading 3\"><Heading3 size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().setParagraph().run()} className={editor.isActive('paragraph') ? 'is-active' : ''} title=\"Text\"><span style={{ fontSize: '12px', fontWeight: 'bold' }}>T</span></button>\r\n\r\n            <button onClick={() => editor.chain().focus().toggleBold().run()} className={editor.isActive('bold') ? 'is-active' : ''} title=\"Bold\"><Bold size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().toggleItalic().run()} className={editor.isActive('italic') ? 'is-active' : ''} title=\"Italic\"><Italic size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().toggleStrike().run()} className={editor.isActive('strike') ? 'is-active' : ''} title=\"Strikethrough\"><Strikethrough size={16} /></button>\r\n\r\n            {!editor.isActive('link') && (\r\n                <button\r\n                    onClick={() => {\r\n                        const url = window.prompt('URL');\r\n                        if (url) editor.chain().focus().setLink({ href: url }).run();\r\n                    }}\r\n                    title=\"Add Link\"\r\n                >\r\n                    <LinkIcon size={16} />\r\n                </button>\r\n            )}\r\n\r\n            {editor.isActive('link') && (\r\n                <>\r\n                    <button\r\n                        onClick={() => {\r\n                            const currentUrl = editor.getAttributes('link').href;\r\n                            const url = window.prompt('Edit URL', currentUrl);\r\n                            if (url === null) return;\r\n\r\n                            // Accurately find the link bounds\r\n                            const { selection, doc } = editor.state;\r\n                            let linkStart = selection.from;\r\n                            let linkEnd = selection.to;\r\n\r\n                            doc.nodesBetween(selection.from, selection.to, (node, pos) => {\r\n                                if (node.marks.find(m => m.type.name === 'link')) {\r\n                                    linkStart = Math.min(linkStart, pos);\r\n                                    linkEnd = Math.max(linkEnd, pos + node.nodeSize);\r\n                                }\r\n                            });\r\n\r\n                            const currentText = doc.textBetween(linkStart, linkEnd, ' ');\r\n                            const text = window.prompt('Edit Display Text', currentText);\r\n\r\n                            if (url === '') {\r\n                                editor.chain().focus().extendMarkRange('link').unsetLink().run();\r\n                                if (text !== null && text !== currentText) {\r\n                                    editor.chain().focus().deleteRange({ from: linkStart, to: linkEnd }).insertContent(text).run();\r\n                                }\r\n                                return;\r\n                            }\r\n\r\n                            if (text !== null && text !== currentText) {\r\n                                editor.chain().focus()\r\n                                    .deleteRange({ from: linkStart, to: linkEnd })\r\n                                    .insertContent({\r\n                                        type: 'text',\r\n                                        text: text,\r\n                                        marks: [{ type: 'link', attrs: { href: url } }]\r\n                                    })\r\n                                    .run();\r\n                            } else {\r\n                                editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run();\r\n                            }\r\n                        }}\r\n                        className=\"is-active\"\r\n                        title=\"Edit Link\"\r\n                        style={{ fontSize: '12px', padding: '4px 8px', whiteSpace: 'nowrap' }}\r\n                    >\r\n                        Edit Link\r\n                    </button>\r\n                    <button\r\n                        onClick={() => {\r\n                            editor.chain().focus().extendMarkRange('link').unsetLink().run();\r\n                        }}\r\n                        title=\"Remove Link\"\r\n                        style={{ color: 'var(--danger-color)', fontSize: '12px', padding: '4px 8px', whiteSpace: 'nowrap' }}\r\n                    >\r\n                        Unlink\r\n                    </button>\r\n                </>\r\n            )}\r\n\r\n            <button onClick={() => editor.chain().focus().toggleCode().run()} className={editor.isActive('code') ? 'is-active' : ''} title=\"Code Inline\"><Code size={16} /></button>\r\n            <div className=\"menu-separator\" />\r\n            <button onClick={() => editor.chain().focus().toggleBulletList().run()} className={editor.isActive('bulletList') ? 'is-active' : ''} title=\"Bullet List\"><List size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().toggleOrderedList().run()} className={editor.isActive('orderedList') ? 'is-active' : ''} title=\"Numbered List\"><ListOrdered size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().toggleTaskList().run()} className={editor.isActive('taskList') ? 'is-active' : ''} title=\"Todo List\"><CheckSquare size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().toggleBlockquote().run()} className={editor.isActive('blockquote') ? 'is-active' : ''} title=\"Quote\"><Quote size={16} /></button>\r\n            <button onClick={() => editor.chain().focus().toggleCodeBlock().run()} className={editor.isActive('codeBlock') ? 'is-active' : ''} title=\"Code Block\"><ExternalLink size={16} /></button>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default function Editor({ fileId }) {\r\n    const { nodes, editNode, removeNode } = useNotes();\r\n    const [file, setFile] = useState(null);\r\n    const saveTimeoutRef = useRef(null);\r\n    const lastSavedContentRef = useRef(''); // Track the last saved state to prevent echo updates\r\n    const [localTitle, setLocalTitle] = useState('');\r\n    const [slashMenu, setSlashMenu] = useState({ isOpen: false, top: 0, left: 0, query: '', triggerIdx: -1, selectedIndex: 0 });\r\n    const [bubbleMenu, setBubbleMenu] = useState({ isOpen: false, top: 0, left: 0 });\r\n    const slashMenuListRef = useRef(null);\r\n\r\n    const debouncedSave = useCallback((updates) => {\r\n        if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);\r\n        saveTimeoutRef.current = setTimeout(() => {\r\n            if (updates.content) {\r\n                updates.content = td.turndown(updates.content);\r\n                // We just converted it to saving-format markdown. Save this to lastSaved.\r\n                lastSavedContentRef.current = updates.content;\r\n            }\r\n            editNode(fileId, updates);\r\n        }, 1000);\r\n    }, [fileId, editNode]);\r\n\r\n    const extensions = useMemo(() => [\r\n        StarterKit.configure({ heading: { levels: [1, 2, 3] }, history: true, codeBlock: false }),\r\n        CodeBlock.configure({\r\n            HTMLAttributes: { class: 'tiptap-code-block' },\r\n        }),\r\n        Link.configure({\r\n            openOnClick: false,\r\n            autolink: true,\r\n            linkOnPaste: true,\r\n            HTMLAttributes: {\r\n                class: 'editor-link',\r\n                rel: 'noopener noreferrer',\r\n                target: '_blank',\r\n            },\r\n        }),\r\n        Placeholder.configure({ placeholder: \"Start typing...\" }),\r\n\r\n        TaskList.configure({\r\n            HTMLAttributes: { 'data-type': 'taskList', class: 'task-list' },\r\n        }).extend({\r\n            parseHTML() {\r\n                return [\r\n                    { tag: 'ul[data-type=\"taskList\"]', priority: 100 },\r\n                    { tag: 'ul.task-list', priority: 100 },\r\n                ];\r\n            }\r\n        }),\r\n        TaskItem.configure({\r\n            HTMLAttributes: { 'data-type': 'taskItem', class: 'task-list-item' },\r\n            keepAttributes: false,\r\n        }).extend({\r\n            addAttributes() {\r\n                return {\r\n                    checked: {\r\n                        default: false,\r\n                        keepAttributes: true,\r\n                        parseHTML: element => {\r\n                            if (element.hasAttribute('data-checked')) return element.getAttribute('data-checked') === 'true';\r\n                            if (element.hasAttribute('checked')) return true;\r\n                            const checkbox = element.querySelector('input[type=\"checkbox\"]');\r\n                            return checkbox ? checkbox.checked : false;\r\n                        },\r\n                        renderHTML: attributes => ({\r\n                            'data-checked': attributes.checked,\r\n                            checked: attributes.checked ? 'checked' : null\r\n                        })\r\n                    },\r\n                    date: {\r\n                        default: '',\r\n                        parseHTML: element => {\r\n                            const attrDate = element.getAttribute('data-date');\r\n                            if (attrDate) return attrDate;\r\n\r\n                            // Fallback: try to extract from text content\r\n                            const text = element.textContent || '';\r\n                            const dateRegex = /@(\\d{4}-\\d{2}-\\d{2}(?:\\s+\\d{2}:\\d{2})?)/;\r\n                            const match = text.match(dateRegex);\r\n                            if (match) {\r\n                                const { parsedDate } = parseDateString(match[1]);\r\n                                // Optional: We could try to physically remove it from the DOM element here \r\n                                // so Tiptap's content ingestion doesn't see it, but that's risky.\r\n                                // Instead, we rely on the attribute being set and our render logic.\r\n                                return parsedDate;\r\n                            }\r\n                            return '';\r\n                        },\r\n                        renderHTML: attributes => ({ 'data-date': attributes.date })\r\n                    },\r\n\r\n                    hasTime: {\r\n                        default: false,\r\n                        parseHTML: element => {\r\n                            if (element.getAttribute('data-has-time')) return element.getAttribute('data-has-time') === 'true';\r\n                            const text = element.textContent || '';\r\n                            return /@\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}/.test(text);\r\n                        },\r\n                        renderHTML: attributes => ({ 'data-has-time': attributes.hasTime })\r\n                    },\r\n                    hasDate: {\r\n                        default: false,\r\n                        parseHTML: element => {\r\n                            if (element.getAttribute('data-has-date')) return element.getAttribute('data-has-date') === 'true';\r\n                            if (element.getAttribute('data-date')) return true;\r\n                            const text = element.textContent || '';\r\n                            return /@\\d{4}-\\d{2}-\\d{2}/.test(text);\r\n                        },\r\n                        renderHTML: attributes => ({ 'data-has-date': attributes.hasDate })\r\n                    }\r\n                };\r\n            },\r\n\r\n\r\n\r\n\r\n            parseHTML() {\r\n                return [\r\n                    { tag: 'li[data-type=\"taskItem\"]', priority: 100 },\r\n                    { tag: 'li.task-list-item', priority: 100 },\r\n                    { tag: 'li', getAttrs: element => element.classList.contains('task-list-item') && { 'data-type': 'taskItem' } },\r\n                ];\r\n            },\r\n\r\n            addNodeView() { return ReactNodeViewRenderer(CustomTaskItemComponent); },\r\n\r\n            addKeyboardShortcuts() {\r\n                return {\r\n                    Enter: () => this.editor.commands.splitListItem(this.name, { checked: false, date: '', hasDate: false, hasTime: false }),\r\n                };\r\n            },\r\n\r\n            renderHTML({ node, HTMLAttributes }) {\r\n                // Ensure data-checked accurately reflects the checked attribute\r\n                return ['li', mergeAttributes(HTMLAttributes, {\r\n                    'data-type': 'taskItem',\r\n                    'data-checked': node.attrs.checked ? 'true' : 'false'\r\n                }), 0];\r\n            },\r\n\r\n\r\n\r\n\r\n            addInputRules() {\r\n                return [\r\n                    new InputRule({\r\n                        find: /^\\s*(\\[([ |xX])\\])\\s$/,\r\n                        handler: ({ state, range, match }) => {\r\n                            const checked = match[2].toLowerCase() === 'x';\r\n                            const { tr } = state;\r\n                            tr.delete(range.from, range.to);\r\n                            return tr.setBlockType(range.from, this.type, { checked });\r\n                        },\r\n                    }),\r\n                ];\r\n            },\r\n            parseHTML() {\r\n                return [\r\n                    { tag: 'li[data-type=\"taskItem\"]', priority: 100 },\r\n                    {\r\n                        tag: 'li.task-list-item',\r\n                        priority: 100,\r\n                        getAttrs: node => {\r\n                            const checkbox = node.querySelector('input[type=\"checkbox\"]');\r\n                            const dateAttr = node.getAttribute('data-date');\r\n                            const hasTimeAttr = node.getAttribute('data-has-time') === 'true';\r\n\r\n                            if (dateAttr) {\r\n                                return { checked: checkbox ? checkbox.checked : false, date: dateAttr, hasDate: true, hasTime: hasTimeAttr };\r\n                            }\r\n\r\n                            // Fallback: Parse from text content (needed for initial load from Markdown)\r\n                            const text = node.innerText || node.textContent || '';\r\n                            const dateMatch = text.match(/@(\\d{2,4}[-\\/\\. ]\\d{2}[-\\/\\. ]\\d{2,4}(?:\\s\\d{2}:\\d{2})?)/);\r\n                            if (dateMatch) {\r\n                                const { parsedDate, hasDate, hasTime } = parseDateString(dateMatch[1]);\r\n                                if (hasDate) {\r\n                                    return { checked: checkbox ? checkbox.checked : false, date: parsedDate, hasDate, hasTime };\r\n                                }\r\n                            }\r\n\r\n                            return { checked: checkbox ? checkbox.checked : false, date: '', hasDate: false, hasTime: false };\r\n                        }\r\n\r\n                    },\r\n                    {\r\n                        tag: 'li',\r\n                        priority: 50,\r\n                        getAttrs: node => {\r\n                            const isTaskListItem = node.classList.contains('task-list-item') ||\r\n                                node.getAttribute('data-type') === 'taskItem' ||\r\n                                node.querySelector('input[type=\"checkbox\"]');\r\n\r\n                            if (!isTaskListItem) return false;\r\n\r\n                            const checkbox = node.querySelector('input[type=\"checkbox\"]');\r\n                            const dateAttr = node.getAttribute('data-date');\r\n                            const hasTimeAttr = node.getAttribute('data-has-time') === 'true';\r\n\r\n                            if (dateAttr) {\r\n                                return { checked: checkbox ? checkbox.checked : false, date: dateAttr, hasDate: true, hasTime: hasTimeAttr };\r\n                            }\r\n\r\n                            // Fallback: Parse from text content\r\n                            const text = node.innerText || node.textContent || '';\r\n                            const dateMatch = text.match(/@(\\d{2,4}[-\\/\\. ]\\d{2}[-\\/\\. ]\\d{2,4}(?:\\s\\d{2}:\\d{2})?)/);\r\n                            if (dateMatch) {\r\n                                const { parsedDate, hasDate, hasTime } = parseDateString(dateMatch[1]);\r\n                                if (hasDate) {\r\n                                    return { checked: checkbox ? checkbox.checked : false, date: parsedDate, hasDate, hasTime };\r\n                                }\r\n                            }\r\n\r\n                            return { checked: checkbox ? checkbox.checked : false, date: '', hasDate: false, hasTime: false };\r\n                        }\r\n\r\n                    }\r\n                ];\r\n            }\r\n\r\n        }),\r\n        Node.create({\r\n            name: 'inlineDateInput', group: 'inline', inline: true, atom: true,\r\n            parseHTML() { return [{ tag: 'span[data-type=\"inline-date\"]' }]; },\r\n            renderHTML({ HTMLAttributes }) { return ['span', mergeAttributes(HTMLAttributes, { 'data-type': 'inline-date' })]; },\r\n            addNodeView() { return ReactNodeViewRenderer(InlineDateInputNodeView); },\r\n            addInputRules() {\r\n                return [new InputRule({\r\n                    find: /(?:^|\\s)(@)$/,\r\n                    handler: ({ state, range }) => {\r\n                        // SCOPE FIX: Only trigger inside a taskItem\r\n                        const $pos = state.doc.resolve(range.from);\r\n                        let isInsideTask = false;\r\n                        for (let i = $pos.depth; i > 0; i--) {\r\n                            if ($pos.node(i).type.name === 'taskItem') {\r\n                                isInsideTask = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!isInsideTask) return null;\r\n\r\n                        state.tr.replaceWith(range.from + 1, range.to, this.type.create());\r\n                    }\r\n                })];\r\n            }\r\n\r\n        })\r\n    ], []);\r\n\r\n    const editor = useEditor({\r\n        extensions,\r\n        content: '',\r\n        onUpdate: ({ editor }) => debouncedSave({ content: editor.getHTML() }),\r\n        onTransaction: () => {\r\n            // Force UI to re-read editor.isActive() to eliminate active state delays\r\n            setForceRender(prev => prev + 1);\r\n        },\r\n        onSelectionUpdate: ({ editor }) => {\r\n            try {\r\n                const { from, to, empty } = editor.state.selection;\r\n\r\n                // Selection can sometimes be out of sync with the view during rapid changes\r\n                if (from < 0 || to > editor.state.doc.content.size) {\r\n                    setBubbleMenu({ isOpen: false, top: 0, left: 0 });\r\n                    return;\r\n                }\r\n\r\n                if (!empty && (to - from) < 5000) {\r\n                    // VERIFY VIEW: Ensure the editor view is ready and not destroyed\r\n                    if (!editor.view || !editor.view.domAtPos) {\r\n                        setBubbleMenu({ isOpen: false, top: 0, left: 0 });\r\n                        return;\r\n                    }\r\n\r\n                    // DEEP SAFETY: Check if the position exists in the current view mapping\r\n                    try {\r\n                        const { node } = editor.view.domAtPos(from);\r\n                        if (!node) {\r\n                            setBubbleMenu({ isOpen: false, top: 0, left: 0 });\r\n                            return;\r\n                        }\r\n\r\n                        // Use coordsAtPos for the end of the selection to place the menu nicely\r\n                        const coords = editor.view.coordsAtPos(to);\r\n                        if (coords && typeof coords.top === 'number' && typeof coords.left === 'number') {\r\n                            setBubbleMenu({\r\n                                isOpen: true,\r\n                                top: coords.top - 50,\r\n                                left: coords.left\r\n                            });\r\n                            setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n                        } else {\r\n                            setBubbleMenu({ isOpen: false, top: 0, left: 0 });\r\n                        }\r\n                    } catch (innerErr) {\r\n                        // This handles cases where domAtPos or coordsAtPos throws\r\n                        setBubbleMenu({ isOpen: false, top: 0, left: 0 });\r\n                    }\r\n                } else {\r\n                    setBubbleMenu({ isOpen: false, top: 0, left: 0 });\r\n\r\n                    if (empty) {\r\n                        const $pos = editor.state.doc.resolve(from);\r\n                        const parent = $pos.parent;\r\n                        if (!parent) return;\r\n\r\n                        // textBetween can throw if offsets are invalid\r\n                        const textBefore = parent.textBetween(0, Math.min($pos.parentOffset, parent.content.size), '\\n');\r\n                        const match = textBefore.match(/(?:^|\\s)\\/([a-zA-Z0-9]*)$/);\r\n\r\n                        if (match) {\r\n                            const query = match[1];\r\n                            const triggerIdx = from - query.length - 1;\r\n\r\n                            try {\r\n                                const coords = editor.view.coordsAtPos(triggerIdx);\r\n                                if (coords && typeof coords.bottom === 'number' && typeof coords.left === 'number') {\r\n                                    const menuHeight = 320;\r\n                                    const viewportHeight = window.innerHeight;\r\n                                    const wouldOverflow = coords.bottom + menuHeight > viewportHeight - 20;\r\n\r\n                                    setSlashMenu({\r\n                                        isOpen: true,\r\n                                        top: wouldOverflow ? Math.max(10, coords.top - menuHeight - 10) : coords.bottom + 4,\r\n                                        left: coords.left,\r\n                                        query: query,\r\n                                        triggerIdx: triggerIdx,\r\n                                        selectedIndex: 0\r\n                                    });\r\n\r\n\r\n\r\n                                } else {\r\n                                    setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n                                }\r\n                            } catch (e) {\r\n                                setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n                            }\r\n                        } else {\r\n                            setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n                        }\r\n                    }\r\n                }\r\n            } catch (err) {\r\n                console.error('Editor: Selection update error', err);\r\n                setBubbleMenu({ isOpen: false, top: 0, left: 0 });\r\n                setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n            }\r\n        },\r\n\r\n        onBlur: () => {\r\n            setBubbleMenu({ isOpen: false, top: 0, left: 0 });\r\n            setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n        }\r\n\r\n    });\r\n\r\n    const handleTitleChange = useCallback((e) => {\r\n        const newName = e.target.value;\r\n        setLocalTitle(newName);\r\n        debouncedSave({ name: newName });\r\n    }, [debouncedSave]);\r\n\r\n    const handleKeyDown = useCallback((e) => {\r\n        if (!slashMenu.isOpen) return;\r\n\r\n        const filteredOptions = SLASH_OPTIONS.filter(opt =>\r\n            opt.label.toLowerCase().includes(slashMenu.query.toLowerCase())\r\n        );\r\n\r\n        if (e.key === 'ArrowDown') {\r\n            e.preventDefault();\r\n            setSlashMenu(prev => ({ ...prev, selectedIndex: (prev.selectedIndex + 1) % filteredOptions.length }));\r\n        } else if (e.key === 'ArrowUp') {\r\n            e.preventDefault();\r\n            setSlashMenu(prev => ({ ...prev, selectedIndex: (prev.selectedIndex - 1 + filteredOptions.length) % filteredOptions.length }));\r\n        } else if (e.key === 'Enter') {\r\n            e.preventDefault();\r\n            const selectedOption = filteredOptions[slashMenu.selectedIndex];\r\n            if (selectedOption) {\r\n                editor.chain().focus().deleteRange({ from: slashMenu.triggerIdx, to: editor.state.selection.from }).run();\r\n                selectedOption.command(editor);\r\n                setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n            }\r\n        } else if (e.key === 'Escape') {\r\n            setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n        }\r\n    }, [slashMenu, editor]);\r\n\r\n    useEffect(() => {\r\n        if (slashMenu.isOpen && slashMenuRef.current) {\r\n            const activeItem = slashMenuRef.current.children[slashMenu.selectedIndex];\r\n            if (activeItem) {\r\n                activeItem.scrollIntoView({ block: 'nearest' });\r\n            }\r\n        }\r\n    }, [slashMenu.selectedIndex, slashMenu.isOpen]);\r\n\r\n    useEffect(() => {\r\n        const f = nodes.find(n => n.id === fileId);\r\n        if (f) {\r\n            const isInitialLoad = !file || file.id !== fileId;\r\n            // Only update if it's NOT the content we just saved (prevent echo)\r\n            const isExternalUpdate = !isInitialLoad &&\r\n                f.content !== (file?.content || '') &&\r\n                f.content !== lastSavedContentRef.current &&\r\n                f.updatedAt > (file?.updatedAt || 0);\r\n\r\n            // Keep file state up to date without necessarily re-loading editor\r\n            setFile(f);\r\n\r\n            if (isInitialLoad || isExternalUpdate) {\r\n                if (isInitialLoad) {\r\n                    setLocalTitle(f.name || '');\r\n                    lastSavedContentRef.current = f.content || ''; // initialize ref\r\n                }\r\n\r\n                if (editor) {\r\n                    let content = f.content || '';\r\n                    // Ensure task list markers have a space after them for markdown-it-task-lists\r\n                    content = content.replace(/^(\\s*-\\s*\\[[ xX]\\])(\\S)/gm, '$1 $2');\r\n\r\n                    let html = md.render(content);\r\n\r\n                    // Convert regular task lists to data-type=\"taskList\" and items to taskItem\r\n                    html = html.replace(/<ul[^>]*class=[\"'][^\"']*task-list[^\"']*[\"'][^>]*>/gi, '<ul data-type=\"taskList\">')\r\n                        .replace(/<li[^>]*class=[\"'][^\"']*task-list-item[^\"']*[\"'][^>]*>/gi, '<li data-type=\"taskItem\">');\r\n\r\n                    // Extract @date and move to attribute, but keep other content clean\r\n                    html = html.replace(/(<li data-type=\"taskItem\"[^>]*>)([\\s\\S]*?)(<\\/li>)/gi, (match, openTag, liContent, closeTag) => {\r\n                        const dateRegex = /@(\\d{4}-\\d{2}-\\d{2}(?:\\s+\\d{2}:\\d{2})?)/;\r\n                        const dateMatch = liContent.match(dateRegex);\r\n                        if (dateMatch) {\r\n                            const dateStr = dateMatch[1];\r\n                            const cleanedContent = liContent.replace(dateRegex, '').trim();\r\n                            // Only add attributes if they don't already exist from a previous parse/save cycle\r\n                            return `${openTag.replace('>', ` data-date=\"${dateStr}\" data-has-date=\"true\" data-has-time=\"${dateStr.includes(':')}\">`)}${cleanedContent}${closeTag}`;\r\n                        }\r\n                        return match;\r\n                    });\r\n\r\n                    const selection = editor.state.selection;\r\n                    editor.commands.setContent(html, false);\r\n\r\n                    if (isExternalUpdate) {\r\n                        try {\r\n                            editor.commands.setTextSelection(selection);\r\n                        } catch (e) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, [fileId, nodes, editor, file?.id]);\r\n\r\n\r\n    if (!file) return null;\r\n\r\n    return (\r\n        <div style={{ display: 'flex', flexDirection: 'column', height: '100%', position: 'relative' }}>\r\n            <div className=\"editor-header\">\r\n                <input\r\n                    className=\"title-input\"\r\n                    value={localTitle}\r\n                    onChange={handleTitleChange}\r\n                    placeholder=\"Note Title\"\r\n                />\r\n                <button\r\n                    className=\"icon-button\"\r\n                    onClick={() => {\r\n                        if (window.confirm(\"Delete this note?\")) removeNode(fileId);\r\n                    }}\r\n                    title=\"Delete Note\"\r\n                    style={{ color: 'var(--danger-color)', marginLeft: 'auto' }}\r\n                >\r\n                    <Trash size={18} />\r\n                </button>\r\n            </div>\r\n\r\n            <div className=\"editor-body\" style={{ flex: 1, overflowY: 'auto', padding: '24px', position: 'relative' }} onKeyDownCapture={handleKeyDown}>\r\n                <EditorContent editor={editor} className=\"tiptap-container\" />\r\n\r\n                {/* Custom Bubble (Formatting) Menu */}\r\n                <BubbleMenuUI editor={editor} bubbleMenu={bubbleMenu} setBubbleMenu={setBubbleMenu} />\r\n\r\n                {/* Custom Slash Menu */}\r\n                {slashMenu.isOpen && (\r\n                    <div style={{\r\n                        position: 'fixed',\r\n                        top: slashMenu.top,\r\n                        left: slashMenu.left,\r\n                        backgroundColor: 'var(--bg-secondary)',\r\n                        border: '1px solid var(--border-color)',\r\n                        borderRadius: '8px',\r\n                        boxShadow: 'var(--shadow-md)',\r\n                        zIndex: 1000,\r\n                        minWidth: '200px',\r\n                        padding: '4px',\r\n                        maxHeight: '300px',\r\n                        overflowY: 'auto'\r\n                    }}>\r\n\r\n                        <ul ref={slashMenuListRef} style={{ listStyle: 'none', margin: 0, padding: 0 }}>\r\n                            {SLASH_OPTIONS.filter(o => o.label.toLowerCase().includes(slashMenu.query.toLowerCase())).map((opt, idx) => (\r\n                                <li\r\n                                    key={idx}\r\n                                    onMouseDown={(e) => {\r\n                                        e.preventDefault();\r\n                                        editor.chain().focus().deleteRange({ from: slashMenu.triggerIdx, to: editor.state.selection.from }).run();\r\n                                        opt.command(editor);\r\n                                        setSlashMenu(prev => ({ ...prev, isOpen: false }));\r\n                                    }}\r\n                                    style={{\r\n                                        padding: '8px 12px',\r\n                                        cursor: 'pointer',\r\n                                        borderRadius: '4px',\r\n                                        backgroundColor: idx === slashMenu.selectedIndex ? 'var(--bg-accent)' : 'transparent',\r\n                                        color: idx === slashMenu.selectedIndex ? 'var(--text-primary)' : 'var(--text-secondary)',\r\n                                        fontSize: '14px',\r\n                                        display: 'flex',\r\n                                        alignItems: 'center',\r\n                                        gap: '12px'\r\n                                    }}\r\n                                >\r\n                                    <span style={{ fontSize: '12px', opacity: 0.6, width: '20px', textAlign: 'center' }}>{opt.icon}</span>\r\n                                    {opt.label}\r\n                                </li>\r\n                            ))}\r\n                        </ul>\r\n                    </div>\r\n                )}\r\n            </div>\r\n\r\n            <style>{`\r\n                .custom-bubble-menu {\r\n                    display: flex;\r\n                    background: var(--bg-secondary);\r\n                    padding: 4px;\r\n                    border-radius: 8px;\r\n                    border: 1px solid var(--border-color);\r\n                    box-shadow: var(--shadow-md);\r\n                    gap: 2px;\r\n                    backdrop-filter: blur(8px);\r\n                }\r\n                .custom-bubble-menu button {\r\n                    background: transparent;\r\n                    border: none;\r\n                    border-radius: 4px;\r\n                    padding: 6px;\r\n                    color: var(--text-secondary);\r\n                    cursor: pointer;\r\n                    display: flex;\r\n                    align-items: center;\r\n                    justify-content: center;\r\n                }\r\n                .custom-bubble-menu button.is-active {\r\n                    background: var(--accent-color);\r\n                    color: white;\r\n                }\r\n                .menu-separator {\r\n                    width: 1px;\r\n                    height: 20px;\r\n                    background: var(--border-color);\r\n                    align-self: center;\r\n                    margin: 0 4px;\r\n                }\r\n                .title-input {\r\n                    background: transparent;\r\n                    border: none;\r\n                    outline: none;\r\n                    font-size: 24px;\r\n                    font-weight: bold;\r\n                    color: var(--text-primary);\r\n                    width: 100%;\r\n                }\r\n                .tiptap-container {\r\n                    user-select: text !important;\r\n                    -webkit-user-select: text !important;\r\n                    outline: none;\r\n                }\r\n                .editor-link {\r\n                    color: var(--accent-color);\r\n                    text-decoration: underline;\r\n                    cursor: pointer;\r\n                }\r\n                .editor-link:hover {\r\n                    opacity: 0.8;\r\n                }\r\n\r\n            `}</style>\r\n        </div>\r\n    );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\components\\FileTree.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\components\\GlobalTasks.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\components\\HelpModal.jsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'logo' is defined but never used. Allowed unused vars must match /^[A-Z_]/u.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":12,"suggestions":[{"messageId":"removeVar","data":{"varName":"logo"},"fix":{"range":[222,232],"text":""},"desc":"Remove unused variable 'logo'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { X, Command, Calendar, FolderPlus, FileText, Move, CheckSquare, Sun, HardDrive, Box, Cloud, RefreshCw } from 'lucide-react';\r\nimport { useNotes } from '../context/NotesContext';\r\nimport logo from '../assets/logo.png';\r\n\r\nexport default function HelpModal({ isOpen, onClose }) {\r\n    const { storageMode, disconnectWorkspace } = useNotes();\r\n    if (!isOpen) return null;\r\n\r\n    const getStorageInfo = () => {\r\n        if (storageMode === 'local') return { name: 'Local Storage', icon: <HardDrive size={18} aria-hidden=\"true\" />, detail: 'Mapped to your computer' };\r\n        if (storageMode === 'gdrive') return { name: 'Google Drive', icon: <Cloud size={18} aria-hidden=\"true\" />, detail: 'Synced via Google' };\r\n        if (storageMode === 'sandbox') return { name: 'Browser Storage', icon: <Box size={18} aria-hidden=\"true\" />, detail: 'Private Vault' };\r\n        return { name: 'Unknown', icon: <Box size={18} aria-hidden=\"true\" />, detail: 'Not connected' };\r\n    };\r\n\r\n    const storage = getStorageInfo();\r\n\r\n    return (\r\n        <div className=\"modal-overlay\" onClick={onClose} role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"help-modal-title\" style={{\r\n            position: 'fixed', inset: 0, backgroundColor: 'rgba(0,0,0,0.5)', zIndex: 100,\r\n            display: 'flex', alignItems: 'center', justifyContent: 'center', backdropFilter: 'blur(3px)'\r\n        }}>\r\n            <div className=\"modal-content\" onClick={e => e.stopPropagation()} style={{\r\n                background: 'var(--bg-primary)', padding: '24px', borderRadius: '12px',\r\n                width: '90%', maxWidth: '450px', boxShadow: 'var(--shadow-lg)', color: 'var(--text-primary)',\r\n                maxHeight: '90vh', overflowY: 'auto'\r\n            }}>\r\n                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>\r\n                    <h2 id=\"help-modal-title\" style={{ margin: 0, fontSize: '1.25rem', fontWeight: 600 }}>App Shortcuts & Help</h2>\r\n                    <button onClick={onClose} className=\"icon-button\" aria-label=\"Close Help\" style={{ border: 'none', background: 'transparent', cursor: 'pointer', color: 'var(--text-secondary)' }}><X size={20} aria-hidden=\"true\" /></button>\r\n                </div>\r\n\r\n                <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>\r\n                    <div style={{ background: 'var(--bg-secondary)', padding: '16px', borderRadius: '12px', border: '1px solid var(--border-color)', marginBottom: '8px' }}>\r\n                        <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '16px' }}>\r\n                            <div style={{ background: 'var(--bg-primary)', padding: '8px', borderRadius: '10px', color: 'var(--accent-color)' }} aria-hidden=\"true\">\r\n                                {storage.icon}\r\n                            </div>\r\n                            <div style={{ flex: 1 }}>\r\n                                <div style={{ fontSize: '11px', color: 'var(--text-tertiary)', textTransform: 'uppercase', fontWeight: 700, letterSpacing: '0.5px' }}>Current Storage</div>\r\n                                <div style={{ fontSize: '15px', fontWeight: 700 }}>{storage.name}</div>\r\n                            </div>\r\n                            <button\r\n                                onClick={() => { disconnectWorkspace(); onClose(); }}\r\n                                className=\"secondary-action-btn\"\r\n                                aria-label=\"Change current storage location\"\r\n                                style={{ padding: '8px 12px', fontSize: '12px', borderStyle: 'dashed', borderRadius: '8px' }}\r\n                            >\r\n                                <RefreshCw size={14} style={{ marginRight: '6px' }} aria-hidden=\"true\" />\r\n                                Change\r\n                            </button>\r\n                        </div>\r\n                        <p style={{ margin: 0, fontSize: '12px', color: 'var(--text-secondary)', opacity: 0.8 }}>\r\n                            {storage.detail}. Your notes are stored here securely and privately.\r\n                        </p>\r\n                    </div>\r\n\r\n                    <div style={{ background: 'var(--bg-secondary)', padding: '16px', borderRadius: '8px' }}>\r\n                        <h3 style={{ margin: '0 0 8px 0', fontSize: '0.95rem', display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                            <Command size={18} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" /> Slash Commands\r\n                        </h3>\r\n                        <p style={{ margin: 0, fontSize: '0.9rem', color: 'var(--text-secondary)', lineHeight: 1.5 }}>\r\n                            Type <kbd style={kbdStyle}>/</kbd> inside any note to open the rich formatting menu. You can quickly add Headings, Todo lists, blockquotes, and lists natively while you type.\r\n                        </p>\r\n                    </div>\r\n\r\n                    <div style={{ background: 'var(--bg-secondary)', padding: '16px', borderRadius: '8px' }}>\r\n                        <h3 style={{ margin: '0 0 8px 0', fontSize: '0.95rem', display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                            <Calendar size={18} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" /> Interactive Timelines\r\n                        </h3>\r\n                        <p style={{ margin: 0, fontSize: '0.9rem', color: 'var(--text-secondary)', lineHeight: 1.5 }}>\r\n                            Inside any <b>Todo List</b> item, simply type <kbd style={kbdStyle}>@</kbd> followed by a date to open the inline parser.\r\n                            You can use natural language like <code>@friday</code>, <code>@next monday 9am</code>, shorthand formats like <code>@15/04</code>, or specific times like <code>@tomorrow 5pm</code>.\r\n                            Press <kbd style={kbdStyle}>Tab</kbd> to quickly auto-fill today's date, or press <b>Enter</b> to lock in your custom date. Once created, the date badge is highly interactive:\r\n                            <br /><br />\r\n                            <b>1. Click to Edit:</b> Click any Date badge to modify the deadline instantly.\r\n                            <br />\r\n                            <b>2. Colour Coded:</b> Badges automatically change colour: <span style={{ color: '#10b981', fontWeight: 600 }}>Green</span> (Future), <span style={{ color: '#f59e0b', fontWeight: 600 }}>Orange</span> (Today), or <span style={{ color: '#ef4444', fontWeight: 600 }}>Red</span> (Overdue).\r\n                        </p>\r\n                    </div>\r\n\r\n                    <div style={{ background: 'var(--bg-secondary)', padding: '16px', borderRadius: '8px' }}>\r\n                        <h3 style={{ margin: '0 0 8px 0', fontSize: '0.95rem', display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                            <CheckSquare size={18} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" /> Global Tasks Dashboard\r\n                        </h3>\r\n                        <p style={{ margin: 0, fontSize: '0.9rem', color: 'var(--text-secondary)', lineHeight: 1.5 }}>\r\n                            Click the <b>Global Tasks</b> button in the sidebar to view a unified dashboard of every Todo item across your entire workspace.\r\n                            <br /><br />\r\n                            <b>Actionable:</b> Check off items directly from the dashboard, or click their interactive Date badges to change deadlines on the fly! Click the text to teleport into the parent Note.\r\n                        </p>\r\n                    </div>\r\n\r\n                    <div style={{ background: 'var(--bg-secondary)', padding: '16px', borderRadius: '8px' }}>\r\n                        <h3 style={{ margin: '0 0 12px 0', fontSize: '0.95rem', display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                            <FileText size={18} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" /> Hotkeys\r\n                        </h3>\r\n                        <div style={{ display: 'grid', gridTemplateColumns: '1fr auto', gap: '12px', fontSize: '0.9rem', color: 'var(--text-secondary)' }}>\r\n                            <span style={{ display: 'flex', alignItems: 'center', gap: '6px' }}><FileText size={14} /> New Note <span style={{ fontSize: '0.85em', opacity: 0.7 }}>(Contextual)</span></span>\r\n                            <div><kbd style={kbdStyle}>Alt</kbd> + <kbd style={kbdStyle}>N</kbd></div>\r\n\r\n                            <span style={{ display: 'flex', alignItems: 'center', gap: '6px' }}><FolderPlus size={14} /> New Folder <span style={{ fontSize: '0.85em', opacity: 0.7 }}>(Contextual)</span></span>\r\n                            <div><kbd style={kbdStyle}>Alt</kbd> + <kbd style={kbdStyle}>F</kbd></div>\r\n\r\n                            <span style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>Go Home</span>\r\n                            <div><kbd style={kbdStyle}>Alt</kbd> + <kbd style={kbdStyle}>H</kbd></div>\r\n\r\n                            <span style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>Change Workspace</span>\r\n                            <div><kbd style={kbdStyle}>Alt</kbd> + <kbd style={kbdStyle}>W</kbd></div>\r\n\r\n                            <span style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>Help</span>\r\n                            <div><kbd style={kbdStyle}>Alt</kbd> + <kbd style={kbdStyle}>/</kbd></div>\r\n                        </div>\r\n                    </div>\r\n\r\n                    <div style={{ background: 'var(--bg-secondary)', padding: '16px', borderRadius: '8px' }}>\r\n                        <h3 style={{ margin: '0 0 8px 0', fontSize: '0.95rem', display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                            <FolderPlus size={18} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" /> Navigation & Features\r\n                        </h3>\r\n                        <p style={{ margin: 0, fontSize: '0.9rem', color: 'var(--text-secondary)', lineHeight: 1.5 }}>\r\n                            <b>Recent Files:</b> Re-open your most recently edited notes straight from the top of the Welcome Screen.<br />\r\n                            <b>Folder Counts:</b> Every folder displays the number of items it contains next to its name.<br />\r\n                            <b>Expand/Collapse All:</b> Use the double-chevron icons at the top of the sidebar to instantly open or close your entire folder tree.<br />\r\n                            <b>Keyboard Control:</b> Use Arrow Keys (<kbd style={kbdStyle}>Ôåæ</kbd> <kbd style={kbdStyle}>Ôåô</kbd> <kbd style={kbdStyle}>ÔåÉ</kbd> <kbd style={kbdStyle}>ÔåÆ</kbd>) to traverse the folder tree. Press <kbd style={kbdStyle}>Enter</kbd> to open.\r\n                        </p>\r\n                    </div>\r\n\r\n                    <div style={{ background: 'var(--bg-secondary)', padding: '16px', borderRadius: '8px' }}>\r\n                        <h3 style={{ margin: '0 0 8px 0', fontSize: '0.95rem', display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                            <Move size={18} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" /> Drag & Drop\r\n                        </h3>\r\n                        <p style={{ margin: 0, fontSize: '0.9rem', color: 'var(--text-secondary)', lineHeight: 1.5 }}>\r\n                            You can click and hold any Note or Folder in the left sidebar to drag it.\r\n                            Drop it onto a <b>Folder</b> to move it inside.\r\n                            Drop it onto the <b>Empty Sidebar Space</b> at the bottom to eject it back to the root level!\r\n                        </p>\r\n                    </div>\r\n                </div>\r\n\r\n                <div style={{ background: 'var(--bg-secondary)', padding: '16px', borderRadius: '8px', marginTop: '16px' }}>\r\n                    <h3 style={{ margin: '0 0 8px 0', fontSize: '0.95rem', display: 'flex', alignItems: 'center', gap: '8px' }}>\r\n                        <Sun size={18} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" /> Theme Toggle\r\n                    </h3>\r\n                    <p style={{ margin: 0, fontSize: '0.9rem', color: 'var(--text-secondary)', lineHeight: 1.5 }}>\r\n                        Click the <b>sun/moon</b> icon in the top right corner to instantly toggle between light and dark themes. Redly remembers your preference automatically!\r\n                    </p>\r\n                </div>\r\n\r\n                <div style={{ marginTop: '24px', textAlign: 'center' }}>\r\n                    <button onClick={onClose} style={{\r\n                        background: 'var(--accent-color)', color: 'white', border: 'none', padding: '10px 32px',\r\n                        borderRadius: '4px', cursor: 'pointer', fontWeight: 600, fontSize: '0.95em',\r\n                        boxShadow: '0 2px 4px rgba(99, 102, 241, 0.3)'\r\n                    }}>Got It!</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nconst kbdStyle = {\r\n    background: 'var(--bg-primary)',\r\n    border: '1px solid var(--border-color)',\r\n    borderRadius: '4px',\r\n    padding: '2px 6px',\r\n    fontSize: '0.85em',\r\n    fontFamily: 'monospace',\r\n    boxShadow: '0 1px 1px rgba(0,0,0,0.05)',\r\n    fontWeight: 600\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\components\\InlineDateInput.jsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":24,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":24,"endColumn":19},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":24,"column":21,"nodeType":"BlockStatement","messageId":"unexpected","endLine":24,"endColumn":24,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[898,899],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\n  29 |     useEffect(() => {\n  30 |         if (!isEditing) {\n> 31 |             setEditValue(display);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  32 |         }\n  33 |     }, [display, isEditing]);\n  34 |","line":31,"column":13,"nodeType":null,"endLine":31,"endColumn":25}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\nimport { getDateColor, parseDateString } from '../utils/dateHelpers';\r\n\r\nexport default function InlineDateInput({\r\n    initialDate,\r\n    initialHasTime,\r\n    isChecked,\r\n    onDateChange,\r\n    onClearDate\r\n}) {\r\n    const isTimeSet = initialHasTime === true || initialHasTime === 'true';\r\n    const [isEditing, setIsEditing] = useState(false);\r\n    const [editValue, setEditValue] = useState('');\r\n\r\n    let display = isTimeSet ? \"Set Date & Time\" : \"Set Date\";\r\n    let dateColor = 'var(--accent-color)';\r\n\r\n    if (initialDate) {\r\n        try {\r\n            const [datePart, timePart] = initialDate.split('T');\r\n            const [y, m, d] = datePart.split('-');\r\n            const formattedTime = (isTimeSet && timePart) ? timePart.substring(0, 5) : '';\r\n            display = `${d}/${m}/${y} ${formattedTime}`.trim();\r\n        } catch (e) { }\r\n        dateColor = getDateColor(initialDate, isTimeSet);\r\n    }\r\n\r\n    // Sync external changes\r\n    useEffect(() => {\r\n        if (!isEditing) {\r\n            setEditValue(display);\r\n        }\r\n    }, [display, isEditing]);\r\n\r\n    const commitDateChange = (val) => {\r\n        if (!val || val.trim() === '') {\r\n            onClearDate(new Event('clear'));\r\n            setIsEditing(false);\r\n            return;\r\n        }\r\n\r\n        const { parsedDate, hasDate, hasTime } = parseDateString(val);\r\n        if (hasDate) {\r\n            onDateChange(parsedDate, hasTime);\r\n        }\r\n        setIsEditing(false);\r\n    };\r\n\r\n    const handleKeyDown = (e) => {\r\n        if (e.key === 'Tab') {\r\n            e.preventDefault();\r\n            const today = new Date();\r\n            const d = String(today.getDate()).padStart(2, '0');\r\n            const m = String(today.getMonth() + 1).padStart(2, '0');\r\n            const y = today.getFullYear();\r\n            setEditValue(`${d}/${m}/${y}`);\r\n        } else if (e.key === 'Enter') {\r\n            e.preventDefault();\r\n            commitDateChange(editValue);\r\n        } else if (e.key === 'Escape') {\r\n            e.preventDefault();\r\n            setIsEditing(false);\r\n            setEditValue(display);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div style={{ position: 'relative', display: 'flex', alignItems: 'center' }}>\r\n            {isEditing ? (\r\n                <input\r\n                    type=\"text\"\r\n                    value={editValue}\r\n                    onChange={(e) => setEditValue(e.target.value)}\r\n                    onKeyDown={handleKeyDown}\r\n                    onBlur={() => commitDateChange(editValue)}\r\n                    autoFocus\r\n                    onClick={(e) => e.stopPropagation()}\r\n                    aria-label=\"Edit due date. Type a date like 'friday' or 'tomorrow 5pm'. Press Tab for today.\"\r\n                    style={{\r\n                        background: 'transparent', border: '1px dashed var(--accent-color)',\r\n                        color: 'var(--accent-color)', fontWeight: '600', fontSize: '11px',\r\n                        fontFamily: 'monospace', padding: '2px 4px', borderRadius: '4px',\r\n                        outline: 'none', width: `${Math.max(editValue.length + 2, 12)}ch`\r\n                    }}\r\n                />\r\n            ) : (\r\n                <button\r\n                    onClick={(e) => {\r\n                        e.stopPropagation();\r\n                        // Pre-fill \"HH:MM\" so it's obvious to the user they can add a time\r\n                        setEditValue(isTimeSet ? display : `${display} HH:MM`);\r\n                        setIsEditing(true);\r\n                    }}\r\n                    aria-label={`Due date: ${display}. Click to edit.`}\r\n                    style={{\r\n                        background: isChecked ? 'var(--bg-secondary)' : dateColor,\r\n                        color: isChecked ? 'var(--text-tertiary)' : 'var(--color-badge-text)',\r\n                        padding: '2px 6px', borderRadius: '4px', border: 'none',\r\n                        fontWeight: '600', fontSize: '0.85em', display: 'inline-flex', alignItems: 'center', gap: '4px', cursor: 'pointer'\r\n                    }}\r\n                    title=\"Click to edit date/time text\"\r\n                >\r\n                    <span aria-hidden=\"true\">{isTimeSet ? 'ÔÅ▒' : '­ƒôà'}</span> Due: {display}\r\n                </button>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\components\\Sidebar.jsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'isInitializing' is assigned a value but never used. Allowed unused vars must match /^[A-Z_]/u.","line":8,"column":100,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":114,"suggestions":[{"messageId":"removeVar","data":{"varName":"isInitializing"},"fix":{"range":[533,549],"text":""},"desc":"Remove unused variable 'isInitializing'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'disconnectWorkspace' is assigned a value but never used. Allowed unused vars must match /^[A-Z_]/u.","line":8,"column":235,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":254,"suggestions":[{"messageId":"removeVar","data":{"varName":"disconnectWorkspace"},"fix":{"range":[668,689],"text":""},"desc":"Remove unused variable 'disconnectWorkspace'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\r\nimport { useNotes } from '../context/NotesContext';\r\nimport { Plus, FolderPlus, X, FileText, Download, Upload, HelpCircle, CheckSquare, ChevronsDown, ChevronsUp, FolderArchive } from 'lucide-react';\r\nimport FileTree from './FileTree';\r\nimport logo from '../assets/logo.png';\r\n\r\nexport default function Sidebar({ isOpen, onClose, onOpenHelp, setShowTasks, onGoHome }) {\r\n    const { tree, nodes, activeFileId, setActiveFileId, addNode, expandAll, collapseAll, editNode, isInitializing, globalAddingState, setGlobalAddingState, lastInteractedNodeId, setLastInteractedNodeId, expandedFolders, toggleFolder, disconnectWorkspace } = useNotes();\r\n    const [newName, setNewName] = useState('');\r\n\r\n    const isAdding = globalAddingState.type;\r\n    const targetFolder = globalAddingState.parentId;\r\n\r\n    const handleAdd = async (e) => {\r\n        e.preventDefault();\r\n        if (!newName.trim()) return;\r\n        await addNode(newName.trim(), isAdding, targetFolder); // Adding to target\r\n        setNewName('');\r\n        setGlobalAddingState({ type: null, parentId: null });\r\n    };\r\n\r\n    const handleNewItem = useCallback((type) => {\r\n        const targetNode = nodes.find(n => n.id === lastInteractedNodeId) || nodes.find(n => n.id === activeFileId);\r\n        const parentId = targetNode ? (targetNode.type === 'folder' ? targetNode.id : targetNode.parentId) : null;\r\n        setGlobalAddingState({ type, parentId });\r\n        if (parentId && !expandedFolders.has(parentId)) toggleFolder(parentId);\r\n    }, [nodes, lastInteractedNodeId, activeFileId, setGlobalAddingState, expandedFolders, toggleFolder]);\r\n\r\n    // Flatten visible nodes for keyboard navigation\r\n    const getVisibleNodes = useCallback(() => {\r\n        const visible = [];\r\n        const traverse = (nodeList) => {\r\n            for (const node of nodeList) {\r\n                visible.push(node);\r\n                if (node.type === 'folder' && expandedFolders.has(node.id) && node.children) {\r\n                    traverse(node.children);\r\n                }\r\n            }\r\n        };\r\n        traverse(tree);\r\n        return visible;\r\n    }, [tree, expandedFolders]);\r\n\r\n    useEffect(() => {\r\n        const handleKeyDown = (e) => {\r\n            // Ignore if typing in an input/textarea\r\n            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.closest('.ProseMirror')) {\r\n                return;\r\n            }\r\n\r\n            if (e.altKey && !e.shiftKey && e.key.toLowerCase() === 'n') {\r\n                e.preventDefault();\r\n                handleNewItem('file');\r\n                return;\r\n            } else if (e.altKey && !e.shiftKey && e.key.toLowerCase() === 'f') {\r\n                e.preventDefault();\r\n                handleNewItem('folder');\r\n                return;\r\n            }\r\n\r\n            // Tree navigation\r\n            const visibleNodes = getVisibleNodes();\r\n            if (visibleNodes.length === 0) return;\r\n\r\n            const currentIndex = visibleNodes.findIndex(n => n.id === lastInteractedNodeId);\r\n            const currentNode = currentIndex !== -1 ? visibleNodes[currentIndex] : null;\r\n\r\n            if (e.key === 'ArrowDown') {\r\n                e.preventDefault();\r\n                if (currentIndex === -1) {\r\n                    setLastInteractedNodeId(visibleNodes[0].id);\r\n                } else if (currentIndex < visibleNodes.length - 1) {\r\n                    setLastInteractedNodeId(visibleNodes[currentIndex + 1].id);\r\n                }\r\n            } else if (e.key === 'ArrowUp') {\r\n                e.preventDefault();\r\n                if (currentIndex > 0) {\r\n                    setLastInteractedNodeId(visibleNodes[currentIndex - 1].id);\r\n                } else if (currentIndex === -1) {\r\n                    setLastInteractedNodeId(visibleNodes[visibleNodes.length - 1].id);\r\n                }\r\n            } else if (e.key === 'ArrowRight' && currentNode) {\r\n                e.preventDefault();\r\n                if (currentNode.type === 'folder') {\r\n                    if (!expandedFolders.has(currentNode.id)) {\r\n                        toggleFolder(currentNode.id);\r\n                    } else if (currentIndex < visibleNodes.length - 1 && visibleNodes[currentIndex + 1].parentId === currentNode.id) {\r\n                        // Move to first child\r\n                        setLastInteractedNodeId(visibleNodes[currentIndex + 1].id);\r\n                    }\r\n                }\r\n            } else if (e.key === 'ArrowLeft' && currentNode) {\r\n                e.preventDefault();\r\n                if (currentNode.type === 'folder' && expandedFolders.has(currentNode.id)) {\r\n                    toggleFolder(currentNode.id);\r\n                } else if (currentNode.parentId) {\r\n                    setLastInteractedNodeId(currentNode.parentId);\r\n                }\r\n            } else if ((e.key === 'Enter' || e.key === ' ') && currentNode) {\r\n                e.preventDefault();\r\n                if (currentNode.type === 'folder') {\r\n                    toggleFolder(currentNode.id);\r\n                } else {\r\n                    setActiveFileId(currentNode.id);\r\n                }\r\n            }\r\n        };\r\n\r\n        window.addEventListener('keydown', handleKeyDown);\r\n        return () => window.removeEventListener('keydown', handleKeyDown);\r\n    }, [handleNewItem, getVisibleNodes, lastInteractedNodeId, expandedFolders, toggleFolder, setActiveFileId, setLastInteractedNodeId]);\r\n\r\n    return (\r\n        <aside className={`sidebar ${isOpen ? 'open' : ''}`} role=\"navigation\" aria-label=\"Main Navigation\">\r\n            <div className=\"sidebar-header\" style={{ padding: '16px', flexDirection: 'column', alignItems: 'stretch', gap: '12px' }}>\r\n                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\r\n                    <div style={{ display: 'flex', flexDirection: 'row', alignItems: 'center', flexWrap: 'wrap', gap: '8px' }}>\r\n                        <div\r\n                            style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}\r\n                            onClick={onGoHome}\r\n                            title=\"Go to Home\"\r\n                            role=\"button\"\r\n                            aria-label=\"Redly Home\"\r\n                        >\r\n                            <img src={logo} alt=\"\" style={{ width: '24px', height: '24px', borderRadius: '6px' }} aria-hidden=\"true\" />\r\n                            <span style={{ fontWeight: 800, color: 'var(--accent-color)' }}>redly</span>\r\n                        </div>\r\n                    </div>\r\n                    <div style={{ display: 'flex', gap: '4px' }}>\r\n                        {expandedFolders.size > 0 ? (\r\n                            <button className=\"icon-button\" onClick={collapseAll} title=\"Collapse All Folders\" aria-label=\"Collapse All Folders\" style={{ marginRight: '8px' }}>\r\n                                <ChevronsUp size={14} aria-hidden=\"true\" />\r\n                            </button>\r\n                        ) : (\r\n                            <button className=\"icon-button\" onClick={expandAll} title=\"Expand All Folders\" aria-label=\"Expand All Folders\" style={{ marginRight: '8px' }}>\r\n                                <ChevronsDown size={14} aria-hidden=\"true\" />\r\n                            </button>\r\n                        )}\r\n                        <div style={{ width: '1px', background: 'var(--border-color)', margin: '4px 0', marginRight: '4px' }}></div>\r\n                        <button className=\"icon-button\" onClick={() => handleNewItem('file')} title=\"New Note (Alt+N)\" aria-label=\"Create New Note\">\r\n                            <Plus size={16} aria-hidden=\"true\" />\r\n                        </button>\r\n                        <button className=\"icon-button\" onClick={() => handleNewItem('folder')} title=\"New Folder (Alt+F)\" aria-label=\"Create New Folder\">\r\n                            <FolderPlus size={16} aria-hidden=\"true\" />\r\n                        </button>\r\n                        {isOpen && (\r\n                            <button className=\"icon-button\" onClick={onClose} style={{ display: 'none' }} aria-label=\"Close Sidebar\">\r\n                                <X size={18} aria-hidden=\"true\" />\r\n                            </button>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n\r\n                <button\r\n                    onClick={setShowTasks}\r\n                    aria-label=\"View Global Tasks\"\r\n                    style={{\r\n                        display: 'flex', alignItems: 'center', gap: '8px', padding: '8px',\r\n                        background: 'var(--bg-secondary)', border: 'none', borderRadius: '6px',\r\n                        color: 'var(--text-primary)', fontSize: '14px', cursor: 'pointer',\r\n                        fontWeight: 500, transition: 'background 0.2s', width: '100%'\r\n                    }}\r\n                    onMouseEnter={(e) => e.target.style.background = 'var(--bg-hover)'}\r\n                    onMouseLeave={(e) => e.target.style.background = 'var(--bg-secondary)'}\r\n                >\r\n                    <CheckSquare size={16} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" />\r\n                    Global Tasks\r\n                </button>\r\n            </div>\r\n\r\n            <div\r\n                className=\"sidebar-content\"\r\n                role=\"tree\"\r\n                aria-label=\"Notes Explorer\"\r\n                onClick={() => setLastInteractedNodeId(null)}\r\n                onDragOver={e => {\r\n                    e.preventDefault();\r\n                    e.dataTransfer.dropEffect = 'move';\r\n                }}\r\n                onDrop={e => {\r\n                    e.preventDefault();\r\n                    // Drop to Root if they drop anywhere in the sidebar content\r\n                    const draggedId = e.dataTransfer.getData('text/plain');\r\n                    if (draggedId) {\r\n                        editNode(draggedId, { parentId: null });\r\n                    }\r\n                }}\r\n\r\n            >\r\n                {isAdding && targetFolder === null && (\r\n                    <form onSubmit={handleAdd} style={{ padding: '8px', display: 'flex', gap: '8px', background: 'transparent', borderBottom: '1px solid var(--border-color)' }}>\r\n                        {isAdding === 'folder' ? <FolderPlus size={16} /> : <FileText size={16} />}\r\n                        <input\r\n                            autoFocus\r\n                            className=\"title-input\"\r\n                            style={{ fontSize: '14px', borderBottom: '1px solid var(--border-color)', borderRadius: 0, width: '100%' }}\r\n                            value={newName}\r\n                            onChange={(e) => setNewName(e.target.value)}\r\n                            placeholder={`New ${isAdding}...`}\r\n                            onBlur={() => setGlobalAddingState({ type: null, parentId: null })}\r\n                        />\r\n                    </form>\r\n                )}\r\n\r\n                {tree.length === 0 && !isAdding ? (\r\n                    <div style={{ padding: '16px', color: 'var(--text-tertiary)', fontSize: '14px', textAlign: 'center' }}>\r\n                        No notes yet. Create one!\r\n                    </div>\r\n                ) : (\r\n                    tree.map(node => <FileTree key={node.id} node={node} depth={0} />)\r\n                )}\r\n            </div>\r\n\r\n            <div className=\"sidebar-footer\" style={{\r\n                padding: '12px',\r\n                borderTop: '1px solid var(--border-color)',\r\n                display: 'flex',\r\n                gap: '8px',\r\n                justifyContent: 'center',\r\n                flexShrink: 0\r\n            }}>\r\n                <button\r\n                    onClick={onOpenHelp}\r\n                    aria-label=\"Open Keyboard Shortcuts and Help\"\r\n                    style={{\r\n                        flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px',\r\n                        background: 'var(--bg-accent)', border: 'none', padding: '8px', borderRadius: '6px',\r\n                        color: 'var(--text-secondary)', cursor: 'pointer', fontSize: '14px'\r\n                    }}\r\n                    title=\"Shortcuts & Help\"\r\n                >\r\n                    <HelpCircle size={16} aria-hidden=\"true\" /> redly Guide\r\n\r\n                </button>\r\n            </div>\r\n        </aside>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\components\\WelcomeScreen.jsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'showRecent' is assigned a value but never used. Allowed unused vars must match /^[A-Z_]/u.","line":77,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":77,"endColumn":22,"suggestions":[{"messageId":"removeVar","data":{"varName":"showRecent"},"fix":{"range":[4380,4390],"text":""},"desc":"Remove unused variable 'showRecent'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'setShowRecent' is assigned a value but never used. Allowed unused vars must match /^[A-Z_]/u.","line":77,"column":24,"nodeType":"Identifier","messageId":"unusedVar","endLine":77,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"setShowRecent"},"fix":{"range":[4390,4405],"text":""},"desc":"Remove unused variable 'setShowRecent'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { useNotes } from '../context/NotesContext';\r\nimport { FileText, FolderPlus, ListTodo, Clock, ChevronDown, ChevronRight, HardDrive, ShieldCheck, Box, Unlock, Monitor, CloudUpload, ArrowRight } from 'lucide-react';\r\nimport logo from '../assets/logo.png';\r\n\r\nconst SHARED_STYLES = `\r\n    .welcome-container { \r\n        display: flex; \r\n        flex-direction: column; \r\n        align-items: center; \r\n        justify-content: center; \r\n        height: 100%; \r\n        width: 100%;\r\n        padding: 40px 20px; \r\n        text-align: center; \r\n        color: var(--text-primary); \r\n        background-color: var(--bg-primary); \r\n        overflow-y: auto; \r\n    }\r\n    \r\n    .primary-action-btn { background: var(--accent-color); color: white; border: none; padding: 16px 32px; border-radius: 12px; font-size: 18px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 14px 0 rgba(0, 112, 243, 0.39); transition: transform 0.2s, box-shadow 0.2s; display: flex; align-items: center; gap: 12px; }\r\n    .primary-action-btn:hover { transform: translateY(-2px); }\r\n    .primary-action-btn:active { transform: scale(0.98); }\r\n    .primary-action-btn:disabled { opacity: 0.5; cursor: not-allowed; }\r\n    \r\n    .secondary-action-btn { background: transparent; border: 1px solid var(--border-color); padding: 12px 24px; border-radius: 12px; font-weight: 600; cursor: pointer; color: var(--text-secondary); transition: all 0.2s; }\r\n    .secondary-action-btn:hover { background: var(--bg-secondary); border-color: var(--text-tertiary); }\r\n\r\n    .welcome-card { display: flex; flex-direction: column; align-items: center; justify-content: center; background: var(--bg-secondary); border: 1px solid var(--border-color); padding: 16px; border-radius: 12px; cursor: pointer; transition: all 0.2s ease; gap: 8px; width: 100%; border-bottom-width: 4px; color: var(--text-primary); }\r\n    .welcome-card:hover { border-color: var(--accent-color); transform: translateY(-2px); }\r\n    .welcome-card:active { transform: translateY(0); border-bottom-width: 1px; margin-top: 3px; }\r\n\r\n    .storage-option-btn { background: var(--bg-secondary); border: 1px solid var(--border-color); padding: 16px; border-radius: 16px; cursor: pointer; text-align: left; max-width: 240px; transition: all 0.2s ease; display: flex; flex-direction: column; align-items: flex-start; height: 100%; border-bottom-width: 4px; color: var(--text-primary); }\r\n    .storage-option-btn:hover { border-color: var(--accent-color); transform: translateY(-4px); }\r\n    .storage-option-btn:active { transform: translateY(0); border-bottom-width: 1px; margin-top: 3px; }\r\n\r\n    .modal-overlay { \r\n        position: fixed; \r\n        top: 0; \r\n        left: 0; \r\n        width: 100%; \r\n        height: 100%; \r\n        background: rgba(0,0,0,0.85); \r\n        backdrop-filter: blur(12px); \r\n        display: flex; \r\n        align-items: center; \r\n        justify-content: center; \r\n        z-index: 100000; \r\n        padding: 20px;\r\n    }\r\n    \r\n    .modal-content { \r\n        background: var(--bg-primary); \r\n        padding: 40px; \r\n        border-radius: 32px; \r\n        border: 1px solid var(--border-color); \r\n        box-shadow: 0 30px 60px rgba(0,0,0,0.5); \r\n        max-width: 500px; \r\n        width: 100%; \r\n        text-align: left; \r\n        animation: modal-in 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\r\n    }\r\n\r\n    @keyframes modal-in {\r\n        from { opacity: 0; transform: scale(0.9) translateY(20px); }\r\n        to { opacity: 1; transform: scale(1) translateY(0); }\r\n    }\r\n\r\n    .recent-file-chip { display: flex; align-items: flex-start; gap: 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); padding: 12px 16px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; text-align: left; width: 100%; }\r\n    .recent-file-chip:hover { border-color: var(--accent-color); background: var(--bg-hover); }\r\n\r\n    .badge-cloud { background: rgba(37, 99, 235, 0.1); color: var(--accent-color); padding: 4px 12px; border-radius: 20px; font-size: 11px; font-weight: 700; text-transform: uppercase; margin-bottom: 8px; }\r\n`;\r\n\r\nexport default function WelcomeScreen({ openHelp }) {\r\n    const { addNode, nodes, setActiveFileId, workspaceHandle, selectWorkspace, needsPermission, grantLocalPermission, installApp, isInstallable } = useNotes();\r\n    const [showRecent, setShowRecent] = useState(true);\r\n    const [status, setStatus] = useState('idle'); // idle, checking, migrating, loading\r\n    const [showBackupModal, setShowBackupModal] = useState(false);\r\n\r\n    const CLIENT_ID = import.meta.env.VITE_GDRIVE_CLIENT_ID;\r\n\r\n    const recentFiles = nodes\r\n        .filter(n => n.type === 'file')\r\n        .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))\r\n        .slice(0, 4);\r\n\r\n    const handleGDriveClick = async () => {\r\n        console.log('[GDrive] Cloud Sync button clicked');\r\n\r\n        // PRE-TRIGGER Auth: Call this immediately in the click handler to stay within the user gesture window.\r\n        // This helps prevent browsers from blocking the Google OAuth popup.\r\n        import('../lib/gdrive').then(m => m.getAccessToken().catch(e => console.warn('[GDrive] Pre-auth failed:', e)));\r\n\r\n        // If they already have nodes and are switching TO GDrive\r\n        if (nodes.length > 0 && workspaceHandle) {\r\n            setShowBackupModal(true);\r\n        } else {\r\n            initGDrive(false);\r\n        }\r\n    };\r\n\r\n    const initGDrive = async (shouldMigrate = false) => {\r\n        setStatus('loading');\r\n        setShowBackupModal(false);\r\n        try {\r\n            await selectWorkspace('gdrive', { migrate: shouldMigrate });\r\n            setStatus('idle');\r\n        } catch (e) {\r\n            console.error('GDrive init failed:', e);\r\n            setStatus('idle');\r\n            alert('Cloud connection failed. Please try again.');\r\n        }\r\n    };\r\n\r\n    const renderLogo = (size = 80) => (\r\n        <div style={{ marginBottom: '24px', display: 'flex', justifyContent: 'center' }}>\r\n            <img src={logo} alt=\"Redly Logo\" style={{ width: `${size}px`, height: `${size}px`, borderRadius: '20px', boxShadow: 'var(--shadow-md)' }} />\r\n        </div>\r\n    );\r\n\r\n    const renderBackupModal = () => {\r\n        if (!showBackupModal) return null;\r\n        return (\r\n            <div className=\"modal-overlay\">\r\n                <div className=\"modal-content\">\r\n                    <div className=\"badge-cloud\">Google Drive Migration</div>\r\n                    <h3 style={{ fontSize: '26px', fontWeight: '800', marginBottom: '12px', letterSpacing: '-0.5px' }}>Move your notes to Google Drive?</h3>\r\n                    <p style={{ color: 'var(--text-secondary)', marginBottom: '32px', lineHeight: '1.6', fontSize: '15px' }}>\r\n                        We detected <strong>{nodes.length}</strong> items in your current storage. Would you like to back them up to Google Drive or start fresh?\r\n                    </p>\r\n\r\n                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>\r\n                        <button onClick={() => initGDrive(true)} className=\"primary-action-btn\" style={{ width: '100%', justifyContent: 'center' }}>\r\n                            <CloudUpload size={20} />\r\n                            Backup & Switch to Google Drive\r\n                        </button>\r\n                        <button onClick={() => initGDrive(false)} className=\"secondary-action-btn\" style={{ width: '100%', borderStyle: 'dashed' }}>\r\n                            Start Fresh in Google Drive\r\n                        </button>\r\n                        <button onClick={() => setShowBackupModal(false)} className=\"secondary-action-btn\" style={{ width: '100%', border: 'none' }}>\r\n                            Go Back\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    };\r\n\r\n    if (status === 'loading') {\r\n        return (\r\n            <div className=\"welcome-container\">\r\n                <style>{SHARED_STYLES}</style>\r\n                {renderLogo()}\r\n                <h1 style={{ fontSize: '24px', fontWeight: '700' }}>Connecting to Google Drive...</h1>\r\n                <p style={{ color: 'var(--text-tertiary)', marginBottom: '32px' }}>Please complete the authentication in the popup window.</p>\r\n                <button onClick={() => setStatus('idle')} className=\"secondary-action-btn\" style={{ border: 'none' }}>\r\n                    Cancel & Go Back\r\n                </button>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    if (needsPermission) {\r\n        return (\r\n            <div className=\"welcome-container\">\r\n                <style>{SHARED_STYLES}</style>\r\n                {renderLogo()}\r\n                <h1 style={{ fontSize: '32px', marginBottom: '16px', fontWeight: '800', letterSpacing: '-0.5px' }}>Reconnect Workspace</h1>\r\n                <p style={{ fontSize: '18px', color: 'var(--text-secondary)', marginBottom: '40px', maxWidth: '500px' }}>\r\n                    Browser security requires you to re-verify access to your local <code>redly</code> folder for this session.\r\n                </p>\r\n                <button onClick={grantLocalPermission} className=\"primary-action-btn\" aria-label=\"Unlock Folder and grant storage permissions\">\r\n                    <Unlock size={24} aria-hidden=\"true\" />\r\n                    Unlock Folder\r\n                </button>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    if (!workspaceHandle) {\r\n        return (\r\n            <div className=\"welcome-container\">\r\n                <style>{SHARED_STYLES}</style>\r\n                {renderLogo()}\r\n                <h1 style={{ fontSize: '42px', marginBottom: '12px', fontWeight: '900', letterSpacing: '-1.5px' }}>Redly</h1>\r\n                <p style={{ fontSize: '18px', color: 'var(--text-secondary)', marginBottom: '48px', maxWidth: '550px', lineHeight: '1.5' }}>\r\n                    Your private, offline-first Markdown knowledge base.\r\n                </p>\r\n\r\n                <div style={{ display: 'flex', gap: '20px', flexWrap: 'wrap', justifyContent: 'center', maxWidth: '1000px', width: '100%' }}>\r\n                    <button onClick={() => selectWorkspace('sandbox')} className=\"storage-option-btn\" aria-label=\"Select Browser Storage: Hidden browser sandbox\">\r\n                        <Box size={24} style={{ color: 'var(--color-future)', marginBottom: '12px' }} aria-hidden=\"true\" />\r\n                        <h3 style={{ fontWeight: '700', fontSize: '16px', marginBottom: '4px' }}>Browser Storage</h3>\r\n                        <p style={{ fontSize: '12px', color: 'var(--text-tertiary)', margin: 0, lineHeight: '1.4' }}>Store notes in a hidden, secure browser sandbox. Fast and zero-config.</p>\r\n                    </button>\r\n\r\n                    <button onClick={() => selectWorkspace('local')} className=\"storage-option-btn\" aria-label=\"Select Local Storage: Visible markdown files on your computer\">\r\n                        <HardDrive size={24} style={{ color: 'var(--accent-color)', marginBottom: '12px' }} aria-hidden=\"true\" />\r\n                        <h3 style={{ fontWeight: '700', fontSize: '16px', marginBottom: '4px' }}>Local Storage</h3>\r\n                        <p style={{ fontSize: '12px', color: 'var(--text-tertiary)', margin: 0, lineHeight: '1.4' }}>Save notes as visible <code>.md</code> files on your computer. Your data, your control.</p>\r\n                    </button>\r\n\r\n                    <button onClick={handleGDriveClick} className=\"storage-option-btn\" aria-label=\"Select Google Drive: Cloud synchronization\">\r\n                        <Monitor size={24} style={{ color: 'var(--color-today)', marginBottom: '12px' }} aria-hidden=\"true\" />\r\n                        <h3 style={{ fontWeight: '700', fontSize: '16px', marginBottom: '4px' }}>Google Drive</h3>\r\n                        <p style={{ fontSize: '12px', color: 'var(--text-tertiary)', margin: 0, lineHeight: '1.4' }}>Connect your Google Drive to sync notes across devices seamlessly.</p>\r\n                    </button>\r\n                </div>\r\n                {renderBackupModal()}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <div className=\"welcome-container\">\r\n            <style>{SHARED_STYLES}</style>\r\n            {renderLogo(60)}\r\n\r\n            {isInstallable && (\r\n                <button\r\n                    onClick={installApp}\r\n                    className=\"pwa-install-banner\"\r\n                    style={{\r\n                        fontSize: '14px',\r\n                        padding: '12px 24px',\r\n                        display: 'flex',\r\n                        alignItems: 'center',\r\n                        justifyContent: 'center',\r\n                        gap: '12px',\r\n                        background: 'var(--bg-secondary)',\r\n                        color: 'var(--accent-color)',\r\n                        border: '1px solid var(--border-color)',\r\n                        borderRadius: '12px',\r\n                        fontWeight: '600',\r\n                        marginBottom: '40px',\r\n                        cursor: 'pointer',\r\n                        width: '100%',\r\n                        maxWidth: '500px',\r\n                        boxShadow: 'var(--shadow-sm)',\r\n                        transition: 'all 0.2s ease'\r\n                    }}\r\n                    onMouseOver={(e) => {\r\n                        e.currentTarget.style.borderColor = 'var(--accent-color)';\r\n                        e.currentTarget.style.transform = 'translateY(-1px)';\r\n                        e.currentTarget.style.boxShadow = 'var(--shadow-md)';\r\n                    }}\r\n                    onMouseOut={(e) => {\r\n                        e.currentTarget.style.borderColor = 'var(--border-color)';\r\n                        e.currentTarget.style.transform = 'translateY(0)';\r\n                        e.currentTarget.style.boxShadow = 'var(--shadow-sm)';\r\n                    }}\r\n                >\r\n                    <ShieldCheck size={20} />\r\n                    <span>Install redly Desktop App</span>\r\n                </button>\r\n            )}\r\n\r\n            <h1 style={{ fontSize: '32px', marginBottom: '32px', fontWeight: '800', letterSpacing: '-0.5px', textAlign: 'center' }}>What's next?</h1>\r\n\r\n            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '16px', width: '100%', maxWidth: '600px', marginBottom: '48px' }}>\r\n                <button onClick={() => addNode('Untitled Note', 'file')} className=\"welcome-card\" aria-label=\"Create a New Note\">\r\n                    <FileText size={24} style={{ color: 'var(--accent-color)' }} aria-hidden=\"true\" />\r\n                    <span style={{ fontWeight: '600' }}>New Note</span>\r\n                </button>\r\n                <button onClick={() => addNode('New Folder', 'folder')} className=\"welcome-card\" aria-label=\"Create a New Folder\">\r\n                    <FolderPlus size={24} style={{ color: 'var(--color-future)' }} aria-hidden=\"true\" />\r\n                    <span style={{ fontWeight: '600' }}>New Folder</span>\r\n                </button>\r\n                <button onClick={openHelp} className=\"welcome-card\" aria-label=\"Open Help and Shortcuts\">\r\n                    <ListTodo size={24} style={{ color: 'var(--color-today)' }} aria-hidden=\"true\" />\r\n                    <span style={{ fontWeight: '600' }}>redly Guide</span>\r\n\r\n                </button>\r\n            </div>\r\n\r\n            {recentFiles.length > 0 && (\r\n                <div style={{ width: '100%', maxWidth: '600px', textAlign: 'left' }}>\r\n                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', color: 'var(--text-tertiary)', fontSize: '13px', fontWeight: '700', textTransform: 'uppercase', marginBottom: '16px', letterSpacing: '1px' }}>\r\n                        <Clock size={14} /> Recent Notes\r\n                    </div>\r\n                    <div style={{ display: 'grid', gap: '12px' }}>\r\n                        {recentFiles.map(file => (\r\n                            <button key={file.id} onClick={() => setActiveFileId(file.id)} className=\"recent-file-chip\">\r\n                                <FileText size={16} style={{ color: 'var(--accent-color)', marginTop: '2px' }} />\r\n                                <div style={{ overflow: 'hidden' }}>\r\n                                    <div style={{ fontWeight: '600', color: 'var(--text-primary)', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{file.name}</div>\r\n                                    <div style={{ fontSize: '11px', color: 'var(--text-tertiary)' }}>{new Date(file.updatedAt).toLocaleDateString()}</div>\r\n                                </div>\r\n                            </button>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n            )}\r\n            {renderBackupModal()}\r\n        </div>\r\n    );\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\context\\NotesContext.jsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":248,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":248,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\r\nimport { loadSavedWorkspace, initWorkspace, requestLocalPermission, clearWorkspaceHandle, getNodes, createNode, updateNode, deleteNode, buildTree, getHandle } from '../lib/db';\r\n\r\nconst NotesContext = createContext(undefined);\r\n\r\nexport const NotesProvider = ({ children }) => {\r\n    const [nodes, setNodes] = useState([]);\r\n    const [workspaceHandle, setWorkspaceHandle] = useState(null); // 'active' flag\r\n    const [storageMode, setStorageMode] = useState(null);\r\n    const [isInitializing, setIsInitializing] = useState(true);\r\n    const [needsPermission, setNeedsPermission] = useState(false);\r\n\r\n    const [activeFileId, setActiveFileId] = useState(() => localStorage.getItem('redly_activeFileId') || null);\r\n    const [expandedFolders, setExpandedFolders] = useState(() => {\r\n        const saved = localStorage.getItem('redly_expandedFolders');\r\n        return saved ? new Set(JSON.parse(saved)) : new Set();\r\n    });\r\n\r\n    const [globalAddingState, setGlobalAddingState] = useState({ type: null, parentId: null });\r\n    const [lastInteractedNodeId, setLastInteractedNodeId] = useState(null);\r\n    const [deferredPrompt, setDeferredPrompt] = useState(null);\r\n\r\n    useEffect(() => {\r\n        const handleBeforeInstallPrompt = (e) => {\r\n            e.preventDefault();\r\n            setDeferredPrompt(e);\r\n        };\r\n        window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);\r\n        return () => window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);\r\n    }, []);\r\n\r\n    const installApp = async () => {\r\n        console.log('installApp called, deferredPrompt available:', !!deferredPrompt);\r\n        if (!deferredPrompt) return;\r\n        try {\r\n            deferredPrompt.prompt();\r\n            const { outcome } = await deferredPrompt.userChoice;\r\n            console.log('PWA Install User Choice Outcome:', outcome);\r\n            if (outcome === 'accepted') {\r\n                setDeferredPrompt(null);\r\n            }\r\n        } catch (err) {\r\n            console.error('PWA Install Prompt Failed:', err);\r\n        }\r\n    };\r\n\r\n    // Initial load - check if user already has a workspace configured\r\n    useEffect(() => {\r\n        const init = async () => {\r\n            try {\r\n                const status = await loadSavedWorkspace();\r\n                if (status === true) {\r\n                    setWorkspaceHandle(true);\r\n                    let mode = await getHandle('workspace_mode');\r\n                    if (!mode) mode = localStorage.getItem('redly_last_storage_mode');\r\n                    console.log('[NotesContext] Detected storage mode:', mode);\r\n                    setStorageMode(mode || 'sandbox');\r\n                    setNodes(await getNodes());\r\n                } else if (status === 'requires_permission') {\r\n                    setNeedsPermission(true);\r\n                }\r\n            } catch (e) {\r\n                console.error(\"[NotesContext] Initialisation failed:\", e);\r\n            } finally {\r\n                setIsInitializing(false);\r\n            }\r\n        };\r\n        init();\r\n    }, []);\r\n\r\n    const loadNodes = useCallback(async () => {\r\n        if (!workspaceHandle) return;\r\n        try {\r\n            const freshNodes = await getNodes();\r\n            // Simple hash comparison to avoid unnecessary state updates\r\n            setNodes(prev => {\r\n                const prevJson = JSON.stringify(prev);\r\n                const nextJson = JSON.stringify(freshNodes);\r\n                if (prevJson === nextJson) return prev;\r\n                return freshNodes;\r\n            });\r\n        }\r\n        catch (e) {\r\n            console.error('Failed to load nodes:', e);\r\n            if (e.status === 401) disconnectWorkspace(); // Handle expired tokens\r\n        }\r\n    }, [workspaceHandle]);\r\n\r\n    // Focus refresh & Periodic polling for GDrive\r\n    useEffect(() => {\r\n        if (!workspaceHandle || storageMode !== 'gdrive') return;\r\n\r\n        const refresh = () => {\r\n            console.log('[GDrive] Refreshing nodes from cloud...');\r\n            loadNodes();\r\n        };\r\n\r\n        window.addEventListener('focus', refresh);\r\n        const poll = setInterval(refresh, 30000); // 30s poll\r\n\r\n        return () => {\r\n            window.removeEventListener('focus', refresh);\r\n            clearInterval(poll);\r\n        };\r\n    }, [workspaceHandle, storageMode, loadNodes]);\r\n\r\n    // Function to request permission on boot if returning to a local folder\r\n    const grantLocalPermission = async () => {\r\n        if (await requestLocalPermission()) {\r\n            setNeedsPermission(false);\r\n            setWorkspaceHandle(true);\r\n            setNodes(await getNodes());\r\n        }\r\n    };\r\n\r\n    // Updated to handle Tiers 1 and 2\r\n    const selectWorkspace = async (mode = 'sandbox', options = {}) => {\r\n        try {\r\n            await initWorkspace(mode, options);\r\n            localStorage.setItem('redly_last_storage_mode', mode); // Fallback for UI sync\r\n            setStorageMode(mode);\r\n            setWorkspaceHandle(true);\r\n            setNodes(await getNodes());\r\n        } catch (e) {\r\n            console.error(\"Workspace selection error\", e);\r\n        }\r\n    };\r\n\r\n    const disconnectWorkspace = async () => {\r\n        await clearWorkspaceHandle();\r\n        setWorkspaceHandle(null);\r\n        setStorageMode(null);\r\n        setNeedsPermission(false);\r\n        setNodes([]);\r\n        setActiveFileId(null);\r\n        setExpandedFolders(new Set());\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (activeFileId) localStorage.setItem('redly_activeFileId', activeFileId);\r\n        else localStorage.removeItem('redly_activeFileId');\r\n    }, [activeFileId]);\r\n\r\n    useEffect(() => {\r\n        localStorage.setItem('redly_expandedFolders', JSON.stringify(Array.from(expandedFolders)));\r\n    }, [expandedFolders]);\r\n\r\n    const tree = buildTree(nodes);\r\n\r\n    const toggleFolder = (folderId) => {\r\n        setExpandedFolders(prev => {\r\n            const next = new Set(prev);\r\n            if (next.has(folderId)) next.delete(folderId);\r\n            else next.add(folderId);\r\n            return next;\r\n        });\r\n    };\r\n\r\n    const expandAll = () => setExpandedFolders(new Set(nodes.filter(n => n.type === 'folder').map(n => n.id)));\r\n    const collapseAll = () => setExpandedFolders(new Set());\r\n\r\n    const addNode = async (name, type, parentId = null) => {\r\n        if (!workspaceHandle) return;\r\n        const safeName = name.replace(/[\\\\/:*?\"<>|]/g, '-').trim();\r\n        const extension = type === 'file' ? '.md' : '';\r\n        const idPath = parentId ? `${parentId}/${safeName}${extension}` : `${safeName}${extension}`;\r\n\r\n        let existingNode = nodes.find(n => n.id === idPath);\r\n        let finalIdPath = idPath;\r\n        let counter = 1;\r\n\r\n        while (existingNode) {\r\n            finalIdPath = `${idPath} (${counter})`;\r\n            existingNode = nodes.find(n => n.id === finalIdPath);\r\n            counter++;\r\n        }\r\n\r\n        const newNode = {\r\n            id: finalIdPath,\r\n            name: safeName, // Use the clean name without extension\r\n            type,\r\n            parentId,\r\n            ...(type === 'file' ? { content: '' } : {})\r\n        };\r\n\r\n\r\n        try {\r\n            await createNode(null, newNode);\r\n            await loadNodes();\r\n\r\n            if (type === 'file') setActiveFileId(newNode.id);\r\n            if (parentId && !expandedFolders.has(parentId)) setExpandedFolders(prev => new Set(prev).add(parentId));\r\n        } catch (e) {\r\n            console.error(\"Failed to add node:\", e);\r\n            alert(\"Error: Could not create \" + type);\r\n        }\r\n\r\n    };\r\n\r\n    const editNode = async (id, updates) => {\r\n        if (!workspaceHandle) return;\r\n        const oldNode = nodes.find(n => n.id === id);\r\n        if (!oldNode) return;\r\n\r\n        if (updates.name) updates.name = updates.name.replace(/[\\\\/:*?\"<>|]/g, '-').replace(/\\.md$/i, '').trim();\r\n\r\n        try {\r\n            const updatedNode = await updateNode(null, id, updates, oldNode);\r\n            if (updatedNode && updatedNode.id !== id) {\r\n                if (activeFileId === id) setActiveFileId(updatedNode.id);\r\n                if (lastInteractedNodeId === id) setLastInteractedNodeId(updatedNode.id);\r\n            }\r\n            await loadNodes();\r\n        } catch (e) {\r\n            console.error(\"Failed to edit node:\", e);\r\n            alert(\"Error: Could not rename accurately or move. \" + (e.message || \"\"));\r\n        }\r\n\r\n    };\r\n\r\n    const removeNode = async (id) => {\r\n        if (!workspaceHandle) return;\r\n        const node = nodes.find(n => n.id === id);\r\n        if (!node) return;\r\n\r\n        try {\r\n            await deleteNode(null, id, node.type, node);\r\n            if (activeFileId === id) setActiveFileId(null);\r\n            if (lastInteractedNodeId === id) setLastInteractedNodeId(null);\r\n            await loadNodes();\r\n        } catch (e) {\r\n            console.error(\"Failed to remove node:\", e);\r\n            alert(\"Error: Could not delete item.\");\r\n        }\r\n\r\n    };\r\n\r\n    const value = {\r\n        nodes, tree, activeFileId, setActiveFileId, expandedFolders, toggleFolder, expandAll, collapseAll,\r\n        addNode, editNode, removeNode, isInitializing, workspaceHandle, storageMode, selectWorkspace, disconnectWorkspace,\r\n        needsPermission, grantLocalPermission, globalAddingState, setGlobalAddingState, lastInteractedNodeId, setLastInteractedNodeId,\r\n        installApp, isInstallable: !!deferredPrompt\r\n    };\r\n\r\n    return <NotesContext.Provider value={value}>{children}</NotesContext.Provider>;\r\n};\r\n\r\nexport const useNotes = () => {\r\n    const context = useContext(NotesContext);\r\n    if (!context) throw new Error('useNotes must be used within a NotesProvider');\r\n    return context;\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\lib\\db.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\lib\\gdrive.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'setHandle' is defined but never used. Allowed unused vars must match /^[A-Z_]/u.","line":2,"column":21,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"setHandle"},"fix":{"range":[64,75],"text":""},"desc":"Remove unused variable 'setHandle'."}]},{"ruleId":"no-async-promise-executor","severity":2,"message":"Promise executor functions should not be async.","line":49,"column":24,"nodeType":"Identifier","messageId":"async","endLine":49,"endColumn":29}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// --- Google Drive API Driver for Redly ---\r\nimport { getHandle, setHandle } from './idb_store';\r\n\r\nlet accessToken = null;\r\n\r\nconst DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';\r\nconst SCOPES = 'https://www.googleapis.com/auth/drive.file';\r\nconst CLIENT_ID = import.meta.env.VITE_GDRIVE_CLIENT_ID;\r\n\r\nconsole.log('[GDrive] Driver initialized. Client ID present:', !!CLIENT_ID);\r\n\r\nconst waitForGoogle = () => {\r\n    return new Promise((resolve) => {\r\n        if (window.google?.accounts?.oauth2) {\r\n            console.log('[GDrive] GIS script already loaded');\r\n            return resolve();\r\n        }\r\n        console.log('[GDrive] Waiting for GIS script...');\r\n        const interval = setInterval(() => {\r\n            if (window.google?.accounts?.oauth2) {\r\n                console.log('[GDrive] GIS script loaded after wait');\r\n                clearInterval(interval);\r\n                resolve();\r\n            }\r\n        }, 100);\r\n        setTimeout(() => {\r\n            clearInterval(interval);\r\n            if (!window.google?.accounts?.oauth2) console.warn('[GDrive] GIS script wait timed out after 5s');\r\n            resolve(); // Try anyway after 5s or handle error\r\n        }, 5000);\r\n    });\r\n};\r\n\r\nexport const resetAccessToken = () => {\r\n    accessToken = null;\r\n    localStorage.removeItem('gdrive_token');\r\n    localStorage.removeItem('gdrive_token_expiry');\r\n};\r\n\r\nexport const getAccessToken = async () => {\r\n    if (accessToken) return accessToken;\r\n    const savedToken = localStorage.getItem('gdrive_token');\r\n    const expiry = localStorage.getItem('gdrive_token_expiry');\r\n    if (savedToken && expiry && Date.now() < parseInt(expiry)) {\r\n        accessToken = savedToken;\r\n        return accessToken;\r\n    }\r\n\r\n    return new Promise(async (resolve, reject) => {\r\n        await waitForGoogle();\r\n        if (!window.google?.accounts?.oauth2) {\r\n            return reject(new Error('Google Identity Services script not loaded. Check your internet connection or Content Security Policy.'));\r\n        }\r\n        if (!CLIENT_ID) {\r\n            return reject(new Error('Google Drive Client ID is missing. Check your .env.local file.'));\r\n        }\r\n\r\n        const client = window.google.accounts.oauth2.initTokenClient({\r\n            client_id: CLIENT_ID,\r\n            scope: SCOPES,\r\n            callback: (response) => {\r\n                console.log('[GDrive] Auth callback received:', response);\r\n                if (response.error) {\r\n                    console.error('[GDrive] Auth error:', response.error, response.error_description || '');\r\n                    reject(new Error(`Google Auth Error: ${response.error}`));\r\n                } else {\r\n                    accessToken = response.access_token;\r\n                    localStorage.setItem('gdrive_token', accessToken);\r\n                    localStorage.setItem('gdrive_token_expiry', (Date.now() + response.expires_in * 1000).toString());\r\n                    console.log('[GDrive] Auth successful, token stored');\r\n                    resolve(accessToken);\r\n                }\r\n            },\r\n            error_callback: (err) => {\r\n                console.error('[GDrive] Token client error:', err);\r\n                reject(err);\r\n            }\r\n        });\r\n        console.log('[GDrive] Requesting access token via GIS popup...');\r\n        try {\r\n            client.requestAccessToken();\r\n        } catch (e) {\r\n            console.error('[GDrive] Failed to trigger requestAccessToken:', e);\r\n            reject(e);\r\n        }\r\n    });\r\n};\r\n\r\nexport const initRootFolder = async () => {\r\n    await getAccessToken();\r\n    const q = \"name = 'redly' and mimeType = 'application/vnd.google-apps.folder' and trashed = false\";\r\n    const data = await driveRequest(`/files?q=${encodeURIComponent(q)}&fields=files(id,name)`);\r\n    const existingFolder = data.files && data.files.find(f => f.name.toLowerCase() === 'redly');\r\n\r\n    if (existingFolder) {\r\n        return existingFolder.id;\r\n    } else {\r\n        const res = await driveRequest('/files', {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                name: 'redly',\r\n                mimeType: 'application/vnd.google-apps.folder',\r\n                description: 'Storage for Redly Markdown notes'\r\n            })\r\n        });\r\n        return res.id;\r\n    }\r\n};\r\n\r\nconst driveRequest = async (path, options = {}) => {\r\n    const token = accessToken || await getAccessToken();\r\n    const url = `https://www.googleapis.com/drive/v3${path}`;\r\n    const res = await fetch(url, {\r\n        ...options,\r\n        headers: {\r\n            ...options.headers,\r\n            'Authorization': `Bearer ${token}`,\r\n            'Content-Type': options.body ? 'application/json' : undefined\r\n        }\r\n    });\r\n    if (!res.ok) throw await res.json();\r\n    return res.json();\r\n};\r\n\r\nexport const getNodes = async () => {\r\n    const rootId = await getHandle('gdrive_root_id');\r\n    if (!rootId) return [];\r\n\r\n    const nodes = [];\r\n    const fetchPath = async (folderId, currentPath = '') => {\r\n        const q = `'${folderId}' in parents and trashed = false`;\r\n        const data = await driveRequest(`/files?q=${encodeURIComponent(q)}&fields=files(id,name,mimeType,modifiedTime)`);\r\n\r\n        for (const file of data.files) {\r\n            const nodePath = currentPath ? `${currentPath}/${file.name}` : file.name;\r\n            if (file.mimeType === 'application/vnd.google-apps.folder') {\r\n                nodes.push({ id: nodePath, name: file.name, type: 'folder', parentId: currentPath || null, gdriveId: file.id });\r\n                await fetchPath(file.id, nodePath);\r\n            } else if (file.name.endsWith('.md')) {\r\n                const contentRes = await fetch(`https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`, {\r\n                    headers: { 'Authorization': `Bearer ${accessToken}` }\r\n                });\r\n                const content = await contentRes.text();\r\n                nodes.push({\r\n                    id: nodePath,\r\n                    name: file.name.replace('.md', ''),\r\n                    type: 'file',\r\n                    parentId: currentPath || null,\r\n                    content,\r\n                    updatedAt: new Date(file.modifiedTime).getTime(),\r\n                    gdriveId: file.id\r\n                });\r\n            }\r\n        }\r\n    };\r\n    await fetchPath(rootId);\r\n    return nodes;\r\n};\r\n\r\nexport const createNode = async (node) => {\r\n    const rootId = await getHandle('gdrive_root_id');\r\n    let parentGDriveId = rootId;\r\n    if (node.parentId) {\r\n        const parts = node.parentId.split('/');\r\n        let currentFolderId = rootId;\r\n        for (const part of parts) {\r\n            const q = `'${currentFolderId}' in parents and name = '${part}' and mimeType = 'application/vnd.google-apps.folder' and trashed = false`;\r\n            const data = await driveRequest(`/files?q=${encodeURIComponent(q)}&fields=files(id)`);\r\n            if (data.files && data.files.length > 0) {\r\n                currentFolderId = data.files[0].id;\r\n            } else {\r\n                currentFolderId = rootId;\r\n                break;\r\n            }\r\n        }\r\n        parentGDriveId = currentFolderId;\r\n    }\r\n\r\n    const metadata = {\r\n        name: node.type === 'file' ? `${node.name}.md` : node.name,\r\n        mimeType: node.type === 'file' ? 'text/markdown' : 'application/vnd.google-apps.folder',\r\n        parents: [parentGDriveId]\r\n    };\r\n\r\n    if (node.type === 'folder') {\r\n        const res = await driveRequest('/files', {\r\n            method: 'POST',\r\n            body: JSON.stringify(metadata)\r\n        });\r\n        return { ...node, gdriveId: res.id };\r\n    } else {\r\n        const form = new FormData();\r\n        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));\r\n        form.append('file', new Blob([node.content || ''], { type: 'text/markdown' }));\r\n\r\n        const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {\r\n            method: 'POST',\r\n            headers: { 'Authorization': `Bearer ${accessToken}` },\r\n            body: form\r\n        });\r\n        const data = await res.json();\r\n        return { ...node, gdriveId: data.id };\r\n    }\r\n};\r\n\r\nexport const updateNode = async (id, updates, oldNode) => {\r\n    if (updates.content !== undefined) {\r\n        await fetch(`https://www.googleapis.com/upload/drive/v3/files/${oldNode.gdriveId}?uploadType=media`, {\r\n            method: 'PATCH',\r\n            headers: {\r\n                'Authorization': `Bearer ${accessToken}`,\r\n                'Content-Type': 'text/markdown'\r\n            },\r\n            body: updates.content\r\n        });\r\n    }\r\n    if (updates.name && updates.name !== oldNode.name) {\r\n        await driveRequest(`/files/${oldNode.gdriveId}`, {\r\n            method: 'PATCH',\r\n            body: JSON.stringify({ name: oldNode.type === 'file' ? `${updates.name}.md` : updates.name })\r\n        });\r\n    }\r\n    if (updates.parentId !== undefined) {\r\n        // Move in GDrive: requires adding new parent and removing old parent\r\n        const rootId = await getHandle('gdrive_root_id');\r\n        let newParentId = rootId;\r\n        if (updates.parentId) {\r\n            // This is a bit simplified, ideally we'd look up the gdriveId of the new parentId path\r\n            // But for now, we'll try to find it in the current nodes list or root\r\n            const newParentNode = (await driveRequest(`/files?q='${rootId}' in parents and name='${updates.parentId.split('/').pop()}'&fields=files(id)`)).files[0];\r\n            if (newParentNode) newParentId = newParentNode.id;\r\n        }\r\n\r\n        // To do a proper move we need the current parents\r\n        const fileInfo = await driveRequest(`/files/${oldNode.gdriveId}?fields=parents`);\r\n        const oldParents = fileInfo.parents.join(',');\r\n\r\n        await driveRequest(`/files/${oldNode.gdriveId}?addParents=${newParentId}&removeParents=${oldParents}`, {\r\n            method: 'PATCH'\r\n        });\r\n    }\r\n\r\n    return { ...oldNode, ...updates };\r\n};\r\n\r\nexport const deleteNode = async (id, type, gdriveId) => {\r\n    await driveRequest(`/files/${gdriveId}`, { method: 'DELETE' });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\lib\\idb_store.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\lib\\local_driver.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'oldPath' is assigned a value but never used. Allowed unused vars must match /^[A-Z_]/u.","line":135,"column":19,"nodeType":"Identifier","messageId":"unusedVar","endLine":135,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"oldPath"},"fix":{"range":[6204,6231],"text":""},"desc":"Remove unused variable 'oldPath'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'type' is defined but never used.","line":151,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":151,"endColumn":42,"suggestions":[{"messageId":"removeVar","data":{"varName":"type"},"fix":{"range":[6721,6727],"text":""},"desc":"Remove unused variable 'type'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// --- Driver for OPFS and Native File System API ---\r\n\r\nlet currentRootHandle = null;\r\n\r\nexport const setRootHandle = (handle) => { currentRootHandle = handle; };\r\n\r\nexport const getDirHandleFromPath = async (path, create = false) => {\r\n    if (!path) return currentRootHandle;\r\n    const parts = path.split('/');\r\n    let handle = currentRootHandle;\r\n    for (const part of parts) {\r\n        handle = await handle.getDirectoryHandle(part, { create });\r\n    }\r\n    return handle;\r\n};\r\n\r\nexport const getNodes = async (dirHandle = currentRootHandle, currentPath = '') => {\r\n    if (!dirHandle) return [];\r\n    const nodes = [];\r\n    try {\r\n        for await (const entry of dirHandle.values()) {\r\n            const nodePath = currentPath ? `${currentPath}/${entry.name}` : entry.name;\r\n\r\n            if (entry.kind === 'file' && entry.name.endsWith('.md')) {\r\n                const file = await entry.getFile();\r\n                const content = await file.text();\r\n                nodes.push({\r\n                    id: nodePath,\r\n                    name: entry.name.replace('.md', ''),\r\n                    type: 'file',\r\n                    parentId: currentPath || null,\r\n                    content,\r\n                    updatedAt: file.lastModified\r\n                });\r\n            } else if (entry.kind === 'directory' && !entry.name.startsWith('.')) {\r\n                nodes.push({ id: nodePath, name: entry.name, type: 'folder', parentId: currentPath || null });\r\n                const children = await getNodes(entry, nodePath);\r\n                nodes.push(...children);\r\n            }\r\n        }\r\n    } catch (err) {\r\n        console.error('Failed to get nodes:', err);\r\n    }\r\n    return nodes;\r\n};\r\n\r\nexport const createNode = async (node) => {\r\n    const parentHandle = await getDirHandleFromPath(node.parentId, true);\r\n    if (node.type === 'folder') {\r\n        await parentHandle.getDirectoryHandle(node.name, { create: true });\r\n    } else {\r\n        const fileHandle = await parentHandle.getFileHandle(`${node.name}.md`, { create: true });\r\n        const writable = await fileHandle.createWritable();\r\n        await writable.write(node.content || '');\r\n        await writable.close();\r\n    }\r\n    return node;\r\n};\r\n\r\n// Helper for recursive folder copy (fallback when .move() is unavailable)\r\nasync function copyFolderContents(sourceHandle, targetHandle) {\r\n    for await (const entry of sourceHandle.values()) {\r\n        if (entry.kind === 'file') {\r\n            const file = await entry.getFile();\r\n            const newFileHandle = await targetHandle.getFileHandle(entry.name, { create: true });\r\n            const writable = await newFileHandle.createWritable();\r\n            await writable.write(await file.arrayBuffer());\r\n            await writable.close();\r\n        } else if (entry.kind === 'directory') {\r\n            const newFolderHandle = await targetHandle.getDirectoryHandle(entry.name, { create: true });\r\n            await copyFolderContents(entry, newFolderHandle);\r\n        }\r\n    }\r\n}\r\n\r\nexport const updateNode = async (id, updates, oldNode) => {\r\n    const parentHandle = await getDirHandleFromPath(oldNode.parentId);\r\n    let currentHandle = oldNode.type === 'file'\r\n        ? await parentHandle.getFileHandle(`${oldNode.name}.md`)\r\n        : await parentHandle.getDirectoryHandle(oldNode.name);\r\n\r\n    let finalNode = { ...oldNode, ...updates };\r\n\r\n    // 1. Handle Renaming or Moving (Storage Level)\r\n    if ((updates.name && updates.name !== oldNode.name) || (updates.parentId !== undefined && updates.parentId !== oldNode.parentId)) {\r\n        const newName = updates.name || oldNode.name;\r\n        const newParentId = updates.parentId !== undefined ? updates.parentId : oldNode.parentId;\r\n        const newParentHandle = await getDirHandleFromPath(newParentId, true);\r\n        const fileName = oldNode.type === 'file' ? `${newName}.md` : newName;\r\n\r\n        let moveSuccessful = false;\r\n        if (currentHandle.move) {\r\n            try {\r\n                await currentHandle.move(newParentHandle, fileName);\r\n                // After move, we need to update the handle reference if we want to write content later\r\n                currentHandle = oldNode.type === 'file'\r\n                    ? await newParentHandle.getFileHandle(fileName)\r\n                    : await newParentHandle.getDirectoryHandle(newName);\r\n                moveSuccessful = true;\r\n            } catch (moveErr) {\r\n                console.warn('Native move failed, falling back to copy/delete:', moveErr);\r\n            }\r\n        }\r\n\r\n        if (!moveSuccessful) {\r\n            // Fallback: Copy and Delete\r\n            if (oldNode.type === 'file') {\r\n                const file = await currentHandle.getFile();\r\n                const content = updates.content !== undefined ? updates.content : await file.text();\r\n                const newFileHandle = await newParentHandle.getFileHandle(fileName, { create: true });\r\n                const writable = await newFileHandle.createWritable();\r\n                await writable.write(content);\r\n                await writable.close();\r\n\r\n                // Ensure we use the correct filename including extension for removal\r\n                const oldFileName = oldNode.type === 'file' ? `${oldNode.name}.md` : oldNode.name;\r\n                await parentHandle.removeEntry(oldFileName, { recursive: oldNode.type === 'folder' });\r\n                currentHandle = newFileHandle;\r\n                // Mark content as handled so we don't write it again below\r\n                updates.content = undefined;\r\n            } else {\r\n                const newFolderHandle = await newParentHandle.getDirectoryHandle(newName, { create: true });\r\n                await copyFolderContents(currentHandle, newFolderHandle);\r\n                await parentHandle.removeEntry(oldNode.name, { recursive: true });\r\n                currentHandle = newFolderHandle;\r\n            }\r\n        }\r\n\r\n\r\n        // Update ID\r\n        if (oldNode.type === 'file') {\r\n            finalNode.id = newParentId ? `${newParentId}/${fileName}` : fileName;\r\n        } else {\r\n            // For folders, we need to be careful with ID replacement if it's a nested path\r\n            const oldPath = oldNode.id;\r\n            const parentPath = oldNode.parentId || '';\r\n            finalNode.id = parentPath ? `${parentPath}/${newName}` : newName;\r\n        }\r\n    }\r\n\r\n    // 2. Handle Content Updates (File only)\r\n    if (oldNode.type === 'file' && updates.content !== undefined) {\r\n        const writable = await currentHandle.createWritable();\r\n        await writable.write(updates.content);\r\n        await writable.close();\r\n    }\r\n\r\n    return finalNode;\r\n};\r\n\r\nexport const deleteNode = async (id, type) => {\r\n    const name = id.split('/').pop();\r\n    const parentId = id.substring(0, id.lastIndexOf('/')) || null;\r\n    const parentHandle = await getDirHandleFromPath(parentId);\r\n    // name already includes .md for files because id is nodePath which is entry.name\r\n    await parentHandle.removeEntry(name, { recursive: true });\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\main.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\utils\\dateHelpers.js","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":82,"column":65,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":82,"endColumn":66,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3113,3114],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3113,3113],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":82,"column":67,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":82,"endColumn":68,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3115,3116],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3115,3115],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":82,"column":83,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":82,"endColumn":84,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3131,3132],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3131,3131],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":82,"column":85,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":82,"endColumn":86,"suggestions":[{"messageId":"removeEscape","fix":{"range":[3133,3134],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[3133,3133],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export const getDateColor = (dateObj, hasTime = false) => {\r\n    if (!dateObj) return 'var(--danger-color)';\r\n\r\n    const now = new Date();\r\n    const target = new Date(dateObj);\r\n\r\n    // Get strictly local Y-M-D for \"is it today\" check\r\n    const nowLocalStr = `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()}`;\r\n    const targetLocalStr = `${target.getFullYear()}-${target.getMonth() + 1}-${target.getDate()}`;\r\n    const isToday = nowLocalStr === targetLocalStr;\r\n\r\n    if (hasTime) {\r\n        // If it's today and the specific time hasn't passed yet, it's \"Today\" (Amber)\r\n        // If the specific time has passed today, it's \"Overdue\" (Red)\r\n        if (target.getTime() < now.getTime()) {\r\n            return 'var(--color-overdue)';\r\n        }\r\n        if (isToday) return 'var(--color-today)';\r\n        return 'var(--color-future)';\r\n    } else {\r\n        // Pure day comparison\r\n        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\r\n        const targetDay = new Date(target.getFullYear(), target.getMonth(), target.getDate());\r\n\r\n        const diffTime = targetDay.getTime() - today.getTime();\r\n        const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));\r\n\r\n        if (diffDays < 0) return 'var(--color-overdue)'; // Overdue\r\n        if (diffDays === 0) return 'var(--color-today)'; // Today\r\n        return 'var(--color-future)'; // Future\r\n    }\r\n};\r\n\r\nexport const parseDateString = (input) => {\r\n    if (!input || !input.trim()) return { parsedDate: '', hasDate: false, hasTime: false };\r\n\r\n    let hasDate = false;\r\n    let hasTime = false;\r\n    let dateObj = new Date(); // default to today for relative times\r\n\r\n    const str = input.trim().toLowerCase();\r\n\r\n    // Extract time (e.g. 5pm, 15:30)\r\n    let timeRegex = /\\b(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)\\b/i;\r\n    let hours = 0;\r\n    let minutes = 0;\r\n\r\n    let timeMatch = str.match(timeRegex);\r\n    let dateStrWithoutTime = str;\r\n\r\n    if (timeMatch) {\r\n        hasTime = true;\r\n        hours = parseInt(timeMatch[1], 10);\r\n        minutes = timeMatch[2] ? parseInt(timeMatch[2], 10) : 0;\r\n        const ampm = timeMatch[3];\r\n\r\n        if (ampm === 'pm' && hours < 12) hours += 12;\r\n        if (ampm === 'am' && hours === 12) hours = 0;\r\n\r\n        dateStrWithoutTime = str.replace(timeMatch[0], '').trim();\r\n    } else {\r\n        const fallbackRegex = /\\b(\\d{1,2}):(\\d{2})\\b/;\r\n        const m = str.match(fallbackRegex);\r\n        if (m) {\r\n            hasTime = true;\r\n            hours = parseInt(m[1], 10);\r\n            minutes = parseInt(m[2], 10);\r\n            dateStrWithoutTime = str.replace(m[0], '').trim();\r\n        }\r\n    }\r\n\r\n    if (!dateStrWithoutTime) {\r\n        // if it was only time, like \"5pm\", assume today\r\n        hasDate = true;\r\n    } else if (dateStrWithoutTime.includes('today')) {\r\n        hasDate = true;\r\n    } else if (dateStrWithoutTime.includes('tomorrow')) {\r\n        dateObj.setDate(dateObj.getDate() + 1);\r\n        hasDate = true;\r\n    } else {\r\n        // DD/MM or DD/MM/YYYY or DD/MM/YY\r\n        const dateMatch = dateStrWithoutTime.match(/\\b(\\d{1,2})[\\/\\-](\\d{1,2})(?:[\\/\\-](\\d{2,4}))?\\b/);\r\n        if (dateMatch) {\r\n            hasDate = true;\r\n            const dStr = parseInt(dateMatch[1], 10);\r\n            const mStr = parseInt(dateMatch[2], 10) - 1;\r\n            dateObj.setMonth(mStr);\r\n            dateObj.setDate(dStr);\r\n            if (dateMatch[3]) {\r\n                let y = parseInt(dateMatch[3], 10);\r\n                if (y < 100) y += 2000;\r\n                dateObj.setFullYear(y);\r\n            }\r\n        } else {\r\n            // Days of week\r\n            const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\r\n            let nextIndex = -1;\r\n            for (let i = 0; i < days.length; i++) {\r\n                if (dateStrWithoutTime.includes(days[i])) {\r\n                    nextIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            if (nextIndex !== -1) {\r\n                hasDate = true;\r\n                const isNext = dateStrWithoutTime.includes('next');\r\n                let dayDiff = nextIndex - dateObj.getDay();\r\n                if (dayDiff <= 0) dayDiff += 7; // Always jump to future\r\n                if (isNext) dayDiff += 7; // jump to week after\r\n                dateObj.setDate(dateObj.getDate() + dayDiff);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!hasDate) {\r\n        return { parsedDate: '', hasDate: false, hasTime: false };\r\n    }\r\n\r\n    const y = dateObj.getFullYear();\r\n    const m = String(dateObj.getMonth() + 1).padStart(2, '0');\r\n    const d = String(dateObj.getDate()).padStart(2, '0');\r\n    let parsedDate = `${y}-${m}-${d}`;\r\n\r\n    if (hasTime) {\r\n        const hh = String(hours).padStart(2, '0');\r\n        const mm = String(minutes).padStart(2, '0');\r\n        parsedDate += `T${hh}:${mm}`;\r\n    }\r\n\r\n    return { parsedDate, hasDate, hasTime };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\src\\utils\\taskParser.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":57,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":57,"endColumn":31},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":57,"column":33,"nodeType":"BlockStatement","messageId":"unexpected","endLine":57,"endColumn":36,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2163,2164],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Parses all tasks from the given nodes.\r\n * Expects nodes to have Markdown content.\r\n */\r\nexport function parseTasksFromNodes(nodes) {\r\n    const tasks = [];\r\n\r\n    // Helper to resolve breadcrumb path for a node\r\n    const getPath = (nodeId) => {\r\n        const path = [];\r\n        let currentId = nodeId;\r\n        while (currentId) {\r\n            const current = nodes.find(n => n.id === currentId);\r\n            if (current) {\r\n                path.unshift(current.name);\r\n                currentId = current.parentId;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return path;\r\n    };\r\n\r\n    const files = nodes.filter(n => n.type === 'file' && n.content);\r\n\r\n    files.forEach(file => {\r\n        const breadcrumbPath = getPath(file.id);\r\n        const lines = file.content.split('\\n');\r\n\r\n        // Regex to match GFM task list items: \"- [ ] text\" or \"- [x] text\"\r\n        const taskRegex = /^\\s*-\\s*\\[([ xX])\\]\\s*(.*)$/;\r\n\r\n        lines.forEach((line, lineIndex) => {\r\n            const match = line.match(taskRegex);\r\n            if (match) {\r\n                const isChecked = match[1].toLowerCase() === 'x';\r\n                let text = match[2].trim();\r\n\r\n                // Advanced date/time extraction\r\n                // Patterns: @YYYY-MM-DD or @YYYY-MM-DD HH:MM\r\n                let date = null;\r\n                let hasTime = false;\r\n\r\n                // Matches @2023-10-27 or @2023-10-27 15:30\r\n                const dateRegex = /@(\\d{4}-\\d{2}-\\d{2}(?:\\s+\\d{2}:\\d{2})?)/;\r\n                const dateMatch = text.match(dateRegex);\r\n                if (dateMatch) {\r\n                    const dateStr = dateMatch[1].replace(' ', 'T');\r\n                    try {\r\n                        const d = new Date(dateStr);\r\n                        if (!isNaN(d.getTime())) {\r\n                            date = d;\r\n                            hasTime = dateMatch[1].includes(':');\r\n                            // Remove the date string from the text to avoid duplication in UI\r\n                            text = text.replace(dateRegex, '').trim();\r\n                        }\r\n                    } catch (e) { }\r\n                }\r\n\r\n\r\n                tasks.push({\r\n                    // Stable ID based on file path and line index\r\n                    id: `${file.id}:L${lineIndex}`,\r\n                    fileId: file.id,\r\n                    lineIndex: lineIndex,\r\n                    path: breadcrumbPath,\r\n                    checked: isChecked,\r\n                    text: text,\r\n                    date: date,\r\n                    hasTime: hasTime\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    return tasks;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\jonat\\Downloads\\redly\\vite.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
